// modules/core/db/cache_lmdb.vitte
// Cache clé/valeur persistant basé sur LMDB, avec TTL optionnel.
//
// Design :
//  - Valeur stockée = [ver:u8=1][expiry:i64_le][payload...]
//    * expiry = epoch secondes ; 0 => jamais expiré.
//  - get() invalide à la volée les entrées expirées.
//  - purge_expired() : balayage best-effort par curseur (limitable).
//  - Backend LMDB délégué via stubs "be_*" à lier côté runtime.
//    (par défaut → panic clair).
//
// API :
//   cache_open(path, db_name, map_size_mb) -> Cache
//   cache_close(&mut Cache)
//   cache_set(&mut Cache, key:&[u8], val:&[u8], ttl_secs:i64) -> bool
//   cache_get(&mut Cache, key:&[u8]) -> Option<Vec<u8>>
//   cache_del(&mut Cache, key:&[u8]) -> bool
//   cache_exists(&mut Cache, key:&[u8]) -> bool
//   cache_touch(&mut Cache, key:&[u8], ttl_secs:i64) -> bool
//   cache_purge_expired(&mut Cache, scan_limit:i32) -> i32
//
// Helpers (sucre) : versions String.

module core.db.cache_lmdb
use std.time

// ————————————————————————————————————————————————————————————————
// Types
// ————————————————————————————————————————————————————————————————
pub struct Cache {
    env: i64,
    db:  i64,
    open: bool,
}

// ————————————————————————————————————————————————————————————————
// Public API
// ————————————————————————————————————————————————————————————————
pub fn cache_open(path: &str, db_name: &str, map_size_mb: i64) -> Cache {
    if map_size_mb <= 0 { panic("cache_lmdb: map_size_mb must be > 0") }
    let env = be_env_open(path, map_size_mb)
    let db  = be_db_open(env, db_name, true)
    return Cache { env, db, open: true }
}

pub fn cache_close(c: &mut Cache) {
    if !c.open { return }
    be_db_close(c.db)
    be_env_close(c.env)
    c.open = false
}

pub fn cache_set(c: &mut Cache, key: &Vec<u8>, val: &Vec<u8>, ttl_secs: i64) -> bool {
    ensure_open(c)
    let expiry = encode_expiry(ttl_secs)
    let blob = encode_value(expiry, val)
    let txn = be_txn_begin(c.env, true)
    let ok  = be_put(txn, c.db, key, blob)
    if ok { be_txn_commit(txn) } else { be_txn_abort(txn) }
    return ok
}

pub fn cache_get(c: &mut Cache, key: &Vec<u8>) -> Option<Vec<u8>> {
    ensure_open(c)
    let txn = be_txn_begin(c.env, false)
    let raw = be_get(txn, c.db, key)
    be_txn_abort(txn) // read-only → abort équiv. (pas d’effets)
    if raw.is_none() { return None }
    let (ver, exp, payload) = decode_value(raw.unwrap())
    if ver != 1 { 
        // format inconnu → on supprime prudemment
        cache_del(c, key)
        return None
    }
    if exp != 0 && now_secs() > exp {
        // expiré : delete lazy
        cache_del(c, key)
        return None
    }
    return Some(payload)
}

pub fn cache_del(c: &mut Cache, key: &Vec<u8>) -> bool {
    ensure_open(c)
    let txn = be_txn_begin(c.env, true)
    let ok = be_del(txn, c.db, key)
    if ok { be_txn_commit(txn) } else { be_txn_abort(txn) }
    return ok
}

pub fn cache_exists(c: &mut Cache, key: &Vec<u8>) -> bool {
    return cache_get(c, key).is_some()
}

pub fn cache_touch(c: &mut Cache, key: &Vec<u8>, ttl_secs: i64) -> bool {
    let v = cache_get(c, key)
    if v.is_none() { return false }
    return cache_set(c, key, v.unwrap(), ttl_secs)
}

// Balayage best-effort : lit jusqu’à scan_limit paires (k,v), supprime
// celles expirées. Retourne le nombre purgé.
pub fn cache_purge_expired(c: &mut Cache, scan_limit: i32) -> i32 {
    ensure_open(c)
    if scan_limit <= 0 { return 0 }
    let mut purged = 0
    let now = now_secs()

    let txn = be_txn_begin(c.env, true)
    let cur = be_cursor_open(txn, c.db)
    let mut scanned = 0
    loop {
        if scanned >= scan_limit { break }
        let kv = be_cursor_next(cur)
        if kv.is_none() { break }
        let (_k, v) = kv.unwrap()
        let (ver, exp, _payload) = decode_value(v)
        if ver == 1 && exp != 0 && now > exp {
            // suppression via cursor (si backend le gère) sinon re-del via key
            be_cursor_del(cur) || {} // hint; si no-op, pas grave
            purged += 1
        }
        scanned += 1
    }
    be_cursor_close(cur)
    be_txn_commit(txn)
    return purged
}

// ————————————————————————————————————————————————————————————————
// Helpers String (sucre)
// ————————————————————————————————————————————————————————————————
pub fn set_str(c: &mut Cache, key: &str, val: &str, ttl_secs: i64) -> bool {
    return cache_set(c, key.as_bytes(), val.as_bytes(), ttl_secs)
}
pub fn get_str(c: &mut Cache, key: &str) -> Option<String> {
    let v = cache_get(c, key.as_bytes())
    if v.is_none() { return None }
    return Some(String::from_utf8_lossy(v.unwrap()))
}
pub fn del_str(c: &mut Cache, key: &str) -> bool {
    return cache_del(c, key.as_bytes())
}

// ————————————————————————————————————————————————————————————————
// Encodage valeur
// ————————————————————————————————————————————————————————————————
const VAL_VER: u8 = 1

fn encode_value(expiry: i64, payload: &Vec<u8>) -> Vec<u8> {
    let mut out = Vec<u8>::with_len(1 + 8 + payload.len(), 0)
    out[0] = VAL_VER
    // i64 little-endian
    out[1] = (expiry & 0xFF) as u8
    out[2] = ((expiry >> 8) & 0xFF) as u8
    out[3] = ((expiry >> 16) & 0xFF) as u8
    out[4] = ((expiry >> 24) & 0xFF) as u8
    out[5] = ((expiry >> 32) & 0xFF) as u8
    out[6] = ((expiry >> 40) & 0xFF) as u8
    out[7] = ((expiry >> 48) & 0xFF) as u8
    out[8] = ((expiry >> 56) & 0xFF) as u8
    let mut i = 0
    while i < payload.len() { out[9+i] = payload[i]; i += 1 }
    return out
}

fn decode_value(b: &Vec<u8>) -> (u8, i64, Vec<u8>) {
    if b.len() < 9 { return (0, 0, Vec<u8>::new()) }
    let ver = b[0]
    let mut e: i64 = 0
    e |= b[1] as i64
    e |= (b[2] as i64) << 8
    e |= (b[3] as i64) << 16
    e |= (b[4] as i64) << 24
    e |= (b[5] as i64) << 32
    e |= (b[6] as i64) << 40
    e |= (b[7] as i64) << 48
    e |= (b[8] as i64) << 56
    let payload = b[9:b.len()].clone()
    return (ver, e, payload)
}

fn encode_expiry(ttl_secs: i64) -> i64 {
    if ttl_secs <= 0 { return 0 }
    let now = now_secs()
    // éviter overflow basique :
    if ttl_secs > 0x7FFF_FFFF { return 0 } // "jamais" si ttl absurde
    return now + ttl_secs
}

fn now_secs() -> i64 {
    return time::now_seconds_utc()
}

fn ensure_open(c: &Cache) {
    if !c.open { panic("cache_lmdb: cache is closed") }
}

// ————————————————————————————————————————————————————————————————
// Backend LMDB — stubs (à lier côté runtime)
// Fournir une impl concrète via FFI (mdb_env_open, mdb_txn_*, mdb_put/get/del, mdb_cursor_*).
// ————————————————————————————————————————————————————————————————
fn be_env_open(_path: &str, _map_size_mb: i64) -> i64 {
    panic("cache_lmdb: no LMDB backend linked (be_env_open)")
}
fn be_env_close(_env: i64) {
    panic("cache_lmdb: no LMDB backend linked (be_env_close)")
}
fn be_db_open(_env: i64, _name: &str, _create: bool) -> i64 {
    panic("cache_lmdb: no LMDB backend linked (be_db_open)")
}
fn be_db_close(_db: i64) {
    panic("cache_lmdb: no LMDB backend linked (be_db_close)")
}
fn be_txn_begin(_env: i64, _write: bool) -> i64 {
    panic("cache_lmdb: no LMDB backend linked (be_txn_begin)")
}
fn be_txn_commit(_txn: i64) {
    panic("cache_lmdb: no LMDB backend linked (be_txn_commit)")
}
fn be_txn_abort(_txn: i64) {
    // read-only ABORT peut être no-op
    panic("cache_lmdb: no LMDB backend linked (be_txn_abort)")
}
fn be_put(_txn: i64, _db: i64, _key: &Vec<u8>, _val: &Vec<u8>) -> bool {
    panic("cache_lmdb: no LMDB backend linked (be_put)")
}
fn be_get(_txn: i64, _db: i64, _key: &Vec<u8>) -> Option<Vec<u8>> {
    panic("cache_lmdb: no LMDB backend linked (be_get)")
}
fn be_del(_txn: i64, _db: i64, _key: &Vec<u8>) -> bool {
    panic("cache_lmdb: no LMDB backend linked (be_del)")
}
fn be_cursor_open(_txn: i64, _db: i64) -> i64 {
    panic("cache_lmdb: no LMDB backend linked (be_cursor_open)")
}
fn be_cursor_next(_cur: i64) -> Option<(Vec<u8>, Vec<u8>)> {
    panic("cache_lmdb: no LMDB backend linked (be_cursor_next)")
}
fn be_cursor_del(_cur: i64) -> bool {
    // optionnel (si non supporté, purge repassera par cache_del)
    return false
}
fn be_cursor_close(_cur: i64) {
    panic("cache_lmdb: no LMDB backend linked (be_cursor_close)")
}

// ————————————————————————————————————————————————————————————————
// Tests (sans backend) — encodage/TTL seulement
// ————————————————————————————————————————————————————————————————
test "value encode/decode roundtrip" {
    let exp: i64 = 123456789
    let v = "payload".as_bytes()
    let blob = encode_value(exp, v)
    let (ver, e2, p2) = decode_value(blob)
    assert ver == 1
    assert e2 == exp
    assert p2 == v
}

test "expiry encoding" {
    let e0 = encode_expiry(0)
    assert e0 == 0
    let e1 = encode_expiry(10)
    assert e1 >= now_secs()
}
