// std/modules/algo/sort.vitte
// Algorithmes de tri : du pédagogique au performant.
// Implémentations sur Vec<i64> (simples, déterministes).
// Complexités et notes à chaque algo.

module std.algo.sort

fn swap(a: &mut Vec<i64>, i: i32, j: i32) {
    let t = a[i]; a[i] = a[j]; a[j] = t
}

// ————————————————————————————————————————————————————————————————————————
// 1. Bubble sort (O(n^2), stable)
// ————————————————————————————————————————————————————————————————————————
pub fn bubble_sort(a: &mut Vec<i64>) {
    let n = a.len()
    let mut i = 0
    while i < n {
        let mut j = 1
        let mut swapped = false
        while j < n - i {
            if a[j-1] > a[j] {
                swap(a, j-1, j)
                swapped = true
            }
            j += 1
        }
        if !swapped { break }
        i += 1
    }
}

// ————————————————————————————————————————————————————————————————————————
// 2. Insertion sort (O(n^2), stable, bon pour petits tableaux)
// ————————————————————————————————————————————————————————————————————————
pub fn insertion_sort(a: &mut Vec<i64>) {
    let n = a.len()
    let mut i = 1
    while i < n {
        let key = a[i]
        let mut j = i
        while j > 0 && a[j-1] > key {
            a[j] = a[j-1]
            j -= 1
        }
        a[j] = key
        i += 1
    }
}

// ————————————————————————————————————————————————————————————————————————
// 3. Selection sort (O(n^2), pas stable)
// ————————————————————————————————————————————————————————————————————————
pub fn selection_sort(a: &mut Vec<i64>) {
    let n = a.len()
    let mut i = 0
    while i < n {
        let mut min_idx = i
        let mut j = i+1
        while j < n {
            if a[j] < a[min_idx] { min_idx = j }
            j += 1
        }
        if min_idx != i {
            swap(a, i, min_idx)
        }
        i += 1
    }
}

// ————————————————————————————————————————————————————————————————————————
// 4. Merge sort (O(n log n), stable, récursif)
// ————————————————————————————————————————————————————————————————————————
pub fn merge_sort(a: &mut Vec<i64>) {
    let n = a.len()
    if n <= 1 { return }
    let mid = n / 2
    let mut left  = a[0:mid].clone()
    let mut right = a[mid:n].clone()
    merge_sort(&mut left)
    merge_sort(&mut right)
    let mut i = 0; let mut j = 0; let mut k = 0
    while i < left.len() && j < right.len() {
        if left[i] <= right[j] {
            a[k] = left[i]; i += 1
        } else {
            a[k] = right[j]; j += 1
        }
        k += 1
    }
    while i < left.len() { a[k] = left[i]; i += 1; k += 1 }
    while j < right.len() { a[k] = right[j]; j += 1; k += 1 }
}

// ————————————————————————————————————————————————————————————————————————
// 5. Quick sort (O(n log n) en moy, O(n^2) pire cas)
// ————————————————————————————————————————————————————————————————————————
pub fn quick_sort(a: &mut Vec<i64>) {
    if a.len() <= 1 { return }
    quick_sort_range(a, 0, a.len() - 1)
}

fn quick_sort_range(a: &mut Vec<i64>, lo: i32, hi: i32) {
    if lo >= hi { return }
    let p = partition(a, lo, hi)
    if p > 0 { quick_sort_range(a, lo, p-1) }
    quick_sort_range(a, p+1, hi)
}

fn partition(a: &mut Vec<i64>, lo: i32, hi: i32) -> i32 {
    let pivot = a[hi]
    let mut i = lo
    let mut j = lo
    while j < hi {
        if a[j] <= pivot {
            swap(a, i, j)
            i += 1
        }
        j += 1
    }
    swap(a, i, hi)
    return i
}

// ————————————————————————————————————————————————————————————————————————
// 6. Heap sort (O(n log n), pas stable)
// ————————————————————————————————————————————————————————————————————————
pub fn heap_sort(a: &mut Vec<i64>) {
    let n = a.len()
    // build max heap
    let mut i = (n/2) - 1
    loop {
        heapify(a, n, i)
        if i == 0 { break }
        i -= 1
    }
    let mut j = n - 1
    loop {
        swap(a, 0, j)
        heapify(a, j, 0)
        if j == 0 { break }
        j -= 1
    }
}

fn heapify(a: &mut Vec<i64>, n: i32, i: i32) {
    let mut largest = i
    let l = 2*i + 1
    let r = 2*i + 2
    if l < n && a[l] > a[largest] { largest = l }
    if r < n && a[r] > a[largest] { largest = r }
    if largest != i {
        swap(a, i, largest)
        heapify(a, n, largest)
    }
}

// ————————————————————————————————————————————————————————————————————————
// 7. Counting sort (O(n+k), stable, pour valeurs >= 0)
// ————————————————————————————————————————————————————————————————————————
pub fn counting_sort(a: &mut Vec<i64>) {
    if a.len() == 0 { return }
    let mut maxv = a[0]
    let mut i = 1
    while i < a.len() {
        if a[i] > maxv { maxv = a[i] }
        i += 1
    }
    if maxv < 0 { panic("counting_sort: négatif non supporté") }
    let k = (maxv + 1) as i32
    let mut count = Vec<i32>::with_len(k as usize, 0)
    i = 0
    while i < a.len() {
        count[a[i] as usize] += 1
        i += 1
    }
    let mut out = Vec<i64>::with_len(a.len(), 0)
    let mut idx = 0
    let mut v = 0
    while v < k {
        let mut c = count[v]
        while c > 0 {
            out[idx] = v as i64
            idx += 1
            c -= 1
        }
        v += 1
    }
    // copier
    i = 0
    while i < a.len() { a[i] = out[i]; i += 1 }
}

// ————————————————————————————————————————————————————————————————————————
// Tests
// ————————————————————————————————————————————————————————————————————————

fn sorted(a: &Vec<i64>) -> bool {
    let mut i = 1
    while i < a.len() {
        if a[i] < a[i-1] { return false }
        i += 1
    }
    return true
}

test "bubble/insertion/selection" {
    let mut v = [5,3,4,1,2]
    bubble_sort(&mut v)
    assert sorted(v)
    let mut v2 = [9,7,8,6]
    insertion_sort(&mut v2)
    assert sorted(v2)
    let mut v3 = [4,2,5,1,3]
    selection_sort(&mut v3)
    assert sorted(v3)
}

test "merge/quick/heap" {
    let mut v = [10,9,8,7,6,5,4,3,2,1]
    merge_sort(&mut v)
    assert sorted(v)
    let mut v2 = [3,7,2,8,1,9]
    quick_sort(&mut v2)
    assert sorted(v2)
    let mut v3 = [12,11,13,5,6,7]
    heap_sort(&mut v3)
    assert sorted(v3)
}

test "counting sort" {
    let mut v = [4,2,2,8,3,3,1]
    counting_sort(&mut v)
    assert sorted(v)
    assert v == [1,2,2,3,3,4,8]
}
