// modules/ds/bloom.vitte
// Bloom filter classique (m bits, k hash) — MPMC-friendly (bits idempotents).
// - bloom_new(m_bits, k)
// - bloom_for_capacity(capacity, fp_hint)   // fp_hint: "1%", "0.1%", "0.01%"
// - add(&mut, key:&[u8]) -> bool            // true si au moins 1 bit nouvellement posé
// - contains(&, key:&[u8]) -> bool
// - union_with(&mut, other) / intersect_with(&mut, other)
// - clear(), m(), k(), approx_items(), fill_ratio()
// - to_bytes() / from_bytes()
// - helpers: add_str/contains_str
//
// Hashes: double hashing à partir de FNV-1a 64 "seedé" deux fois.
// Indices: idx_i = (h1 + i*h2) mod m    (h2 forcé impair pour éviter cycles triviaux)
//
// Sérialisation (LE):
//  [magic:4 "BLM1"][m:i32][k:i32][n_approx:i64][bits:ceil(m/8)]

module ds.bloom

// ————————————————————————————————————————————————————————————————
// Public type
// ————————————————————————————————————————————————————————————————
pub struct Bloom {
    m_bits:   i32,     // taille en bits
    k_hashes: i32,     // nombre de hash
    n_approx: i64,     // inserts "utiles" (avec au moins 1 bit neuf)
    bits:     Vec<u8>, // bitset (little endian par octet)
}

// ————————————————————————————————————————————————————————————————
// Construction
// ————————————————————————————————————————————————————————————————
pub fn bloom_new(m_bits: i32, k: i32) -> Bloom {
    if m_bits <= 8 { panic("bloom: m_bits must be > 8") }
    if k <= 0 { panic("bloom: k must be >= 1") }
    let bytes = (m_bits + 7) / 8
    return Bloom {
        m_bits: m_bits,
        k_hashes: k,
        n_approx: 0,
        bits: Vec<u8>::with_len(bytes as usize, 0),
    }
}

// constructeur par "profil" (bits/élément & k prédéfinis)
// profils conservateurs : proches de l'optimum sans log/exp.
pub fn bloom_for_capacity(capacity: i32, fp_hint: &str) -> Bloom {
    if capacity <= 0 { panic("bloom: capacity must be > 0") }
    // presets: (bits per item, k)
    //  ~1%   → 9.6 bpi, 7 hashes
    //  ~0.1% → 14.4 bpi, 10 hashes
    //  ~0.01%→ 19.2 bpi, 13 hashes
    let mut bpi = 10
    let mut k   = 7
    if fp_hint == "0.1%" {
        bpi = 14; k = 10
    } else if fp_hint == "0.01%" {
        bpi = 19; k = 13
    } else if fp_hint == "1%" {
        bpi = 10; k = 7
    } else {
        // valeur libre "x.y%" ? on clippe à 1%
        bpi = 10; k = 7
    }
    let m_bits = capacity * bpi
    return bloom_new(m_bits, k)
}

// ————————————————————————————————————————————————————————————————
// API
// ————————————————————————————————————————————————————————————————
pub fn add(b: &mut Bloom, key: &Vec<u8>) -> bool {
    let (h1, mut h2) = twin_hash64(key)
    if h2 == 0 { h2 = 0x9e3779b97f4a7c15 } // golden ratio mix, éviter step 0
    if (h2 & 1) == 0 { h2 = h2 ^ 1 }        // forcer impair

    let mut newly = 0
    let m = b.m_bits as i64

    let mut i = 0
    while i < b.k_hashes {
        // idx = (h1 + i*h2) mod m
        let mut idx = h1.wrapping_add((i as i64).wrapping_mul(h2))
        // mod m Bits (m>0), replier en positif
        idx = idx & 0x7FFF_FFFF_FFFF_FFFF
        idx = idx % m
        if set_bit(&mut b.bits, idx as i32) { newly += 1 }
        i += 1
    }
    if newly > 0 { b.n_approx += 1 }
    return newly > 0
}

pub fn contains(b: &Bloom, key: &Vec<u8>) -> bool {
    let (h1, mut h2) = twin_hash64(key)
    if h2 == 0 { h2 = 0x9e3779b97f4a7c15 }
    if (h2 & 1) == 0 { h2 = h2 ^ 1 }
    let m = b.m_bits as i64

    let mut i = 0
    while i < b.k_hashes {
        let mut idx = h1.wrapping_add((i as i64).wrapping_mul(h2))
        idx = idx & 0x7FFF_FFFF_FFFF_FFFF
        idx = idx % m
        if !get_bit(&b.bits, idx as i32) { return false }
        i += 1
    }
    return true
}

pub fn add_str(b: &mut Bloom, s: &str) -> bool { return add(b, s.as_bytes()) }
pub fn contains_str(b: &Bloom, s: &str) -> bool { return contains(b, s.as_bytes()) }

pub fn union_with(a: &mut Bloom, other: &Bloom) {
    ensure_compat(a, other)
    let mut i = 0
    while i < a.bits.len() {
        a.bits[i] = a.bits[i] | other.bits[i]
        i += 1
    }
}
pub fn intersect_with(a: &mut Bloom, other: &Bloom) {
    ensure_compat(a, other)
    let mut i = 0
    while i < a.bits.len() {
        a.bits[i] = a.bits[i] & other.bits[i]
        i += 1
    }
}

pub fn clear(b: &mut Bloom) {
    let mut i = 0
    while i < b.bits.len() { b.bits[i] = 0; i += 1 }
    b.n_approx = 0
}

pub fn m(b: &Bloom) -> i32 { return b.m_bits }
pub fn k(b: &Bloom) -> i32 { return b.k_hashes }
pub fn approx_items(b: &Bloom) -> i64 { return b.n_approx }

// ratio de bits à 1
pub fn fill_ratio(b: &Bloom) -> f64 {
    let ones = popcount_bytes(&b.bits) as f64
    let total = (b.m_bits as f64)
    // chaque bit appartient à un octet ; on doit diviser par m_bits, pas bits.len()*8
    return ones / total
}

// ————————————————————————————————————————————————————————————————
// Sérialisation
// ————————————————————————————————————————————————————————————————
pub fn to_bytes(b: &Bloom) -> Vec<u8> {
    let mut out = Vec<u8>::with_len(4 + 4 + 4 + 8 + b.bits.len(), 0)
    // magic "BLM1"
    out[0]=0x42; out[1]=0x4C; out[2]=0x4D; out[3]=0x31
    put_le_i32(&mut out, 4,  b.m_bits)
    put_le_i32(&mut out, 8,  b.k_hashes)
    put_le_i64(&mut out, 12, b.n_approx)
    // bits
    let mut i = 0
    while i < b.bits.len() { out[20+i] = b.bits[i]; i += 1 }
    return out
}

pub fn from_bytes(buf: &Vec<u8>) -> Bloom {
    if buf.len() < 20 { panic("bloom: blob too small") }
    if !(buf[0]==0x42 && buf[1]==0x4C && buf[2]==0x4D && buf[3]==0x31) {
        panic("bloom: bad magic")
    }
    let m_bits   = get_le_i32(buf, 4)
    let k_hashes = get_le_i32(buf, 8)
    let n_approx = get_le_i64(buf, 12)
    let bytes = (m_bits + 7) / 8
    if buf.len() != 20 + bytes { panic("bloom: size mismatch") }
    let bits = buf[20:20+bytes].clone()
    return Bloom { m_bits, k_hashes, n_approx, bits }
}

// ————————————————————————————————————————————————————————————————
// Internals: hashing, bitset, utils
// ————————————————————————————————————————————————————————————————
fn twin_hash64(key: &Vec<u8>) -> (i64, i64) {
    // Deux FNV-1a 64 "seedés" différemment + mélange final.
    let h1 = fnv1a64_seed(key, 0xcbf29ce484222325)
    let h2 = fnv1a64_seed(key, 0x9e3779b97f4a7c15) ^ rotl64(h1, 13)
    return (h1, h2)
}

fn fnv1a64_seed(data: &Vec<u8>, seed: i64) -> i64 {
    let mut h: i64 = 0xcbf29ce484222325 ^ seed
    let prime: i64 = 0x100000001b3
    let mut i = 0
    while i < data.len() {
        h = h ^ (data[i] as i64)
        h = (h * prime) & 0xFFFF_FFFF_FFFF_FFFF
        i += 1
    }
    return h
}

fn rotl64(x: i64, n: i32) -> i64 {
    let r = ((x << n) | ((x >> (64 - n)) & 0x7FFF_FFFF_FFFF_FFFF)) & 0xFFFF_FFFF_FFFF_FFFF
    return r
}

fn set_bit(bits: &mut Vec<u8>, idx: i32) -> bool {
    let byte = idx >> 3
    let mask = 1u8 << (idx & 7)
    let old = bits[byte as usize]
    let newv = old | mask
    bits[byte as usize] = newv
    return newv != old
}
fn get_bit(bits: &Vec<u8>, idx: i32) -> bool {
    let byte = idx >> 3
    let mask = 1u8 << (idx & 7)
    return (bits[byte as usize] & mask) != 0
}

fn popcount_bytes(b: &Vec<u8>) -> i32 {
    // table 256 → popcount
    static POP: [i32; 256] = build_pop_lut()
    let mut s = 0
    let mut i = 0
    // seuls les m_bits premiers bits comptent ; attention au dernier octet
    while i + 1 < b.len() { s += POP[b[i] as usize]; i += 1 }
    if b.len() > 0 {
        s += POP[b[b.len()-1] as usize]
    }
    return s
}

// Constante générée au compile-time (ici "inline" pour simplicité)
fn build_pop_lut() -> [i32;256] {
    let mut t = [0;256]
    let mut i = 0
    while i < 256 {
        let mut v = i
        let mut c = 0
        while v > 0 { c += v & 1; v = v >> 1 }
        t[i] = c
        i += 1
    }
    return t
}

fn ensure_compat(a: &Bloom, b: &Bloom) {
    if a.m_bits != b.m_bits || a.k_hashes != b.k_hashes {
        panic("bloom: incompatible (m/k differ)")
    }
}

// little-endian helpers
fn put_le_i32(out: &mut Vec<u8>, off: i32, x: i32) {
    out[off]   = (x & 0xFF) as u8
    out[off+1] = ((x>>8) & 0xFF) as u8
    out[off+2] = ((x>>16)& 0xFF) as u8
    out[off+3] = ((x>>24)& 0xFF) as u8
}
fn put_le_i64(out: &mut Vec<u8>, off: i32, x: i64) {
    out[off]   = (x & 0xFF) as u8
    out[off+1] = ((x>>8) & 0xFF) as u8
    out[off+2] = ((x>>16)& 0xFF) as u8
    out[off+3] = ((x>>24)& 0xFF) as u8
    out[off+4] = ((x>>32)& 0xFF) as u8
    out[off+5] = ((x>>40)& 0xFF) as u8
    out[off+6] = ((x>>48)& 0xFF) as u8
    out[off+7] = ((x>>56)& 0xFF) as u8
}
fn get_le_i32(b: &Vec<u8>, off: i32) -> i32 {
    return  (b[off] as i32)
          | ((b[off+1] as i32)<<8)
          | ((b[off+2] as i32)<<16)
          | ((b[off+3] as i32)<<24)
}
fn get_le_i64(b: &Vec<u8>, off: i32) -> i64 {
    return  (b[off] as i64)
          | ((b[off+1] as i64)<<8)
          | ((b[off+2] as i64)<<16)
          | ((b[off+3] as i64)<<24)
          | ((b[off+4] as i64)<<32)
          | ((b[off+5] as i64)<<40)
          | ((b[off+6] as i64)<<48)
          | ((b[off+7] as i64)<<56)
}

// ————————————————————————————————————————————————————————————————
// Tests
// ————————————————————————————————————————————————————————————————
test "basic add/contains roundtrip" {
    let mut bf = bloom_new(1024, 7)
    assert !contains_str(&bf, "vincent")
    let fresh = add_str(&mut bf, "vincent")
    assert fresh
    assert contains_str(&bf, "vincent")
    assert !contains_str(&bf, "vitte")
}

test "union & intersect" {
    let mut a = bloom_new(512, 5)
    let mut b = bloom_new(512, 5)
    add_str(&mut a, "a"); add_str(&mut a, "b")
    add_str(&mut b, "b"); add_str(&mut b, "c")
    let mut u = bloom_new(512, 5)
    u.bits = a.bits.clone(); u.k_hashes=a.k_hashes; u.m_bits=a.m_bits
    union_with(&mut u, &b)
    assert contains_str(&u, "a") && contains_str(&u, "b") && contains_str(&u, "c")

    let mut i = bloom_new(512, 5)
    i.bits = a.bits.clone(); i.k_hashes=a.k_hashes; i.m_bits=a.m_bits
    intersect_with(&mut i, &b)
    assert contains_str(&i, "b")
    assert !contains_str(&i, "a") && !contains_str(&i, "c")
}

test "serialize/deserialize" {
    let mut bf = bloom_for_capacity(1000, "1%")
    add_str(&mut bf, "hello"); add_str(&mut bf, "world")
    let blob = to_bytes(&bf)
    let bf2 = from_bytes(blob)
    assert bf2.m_bits == bf.m_bits && bf2.k_hashes == bf.k_hashes
    assert contains_str(&bf2, "hello") && contains_str(&bf2, "world")
}

test "fill_ratio sane" {
    let mut bf = bloom_new(256, 3)
    let r0 = fill_ratio(&bf)
    add_str(&mut bf, "x")
    let r1 = fill_ratio(&bf)
    assert r1 >= r0
}
