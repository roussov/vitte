(* ========================================================================= *)
(*  Vitte — Grammaire officielle .ebnf (référence initiale)                  *)
(*  Dialecte inspiré de Rust-like, conforme aux exemples DSU/Graph.         *)
(*  Notation : EBNF ISO 14977                                               *)
(* ========================================================================= *)

(* =============================== LEXIQUE ================================= *)

letter           = "A" | "B" | "C" | "D" | "E" | "F" | "G" | "H" | "I" | "J" |
                   "K" | "L" | "M" | "N" | "O" | "P" | "Q" | "R" | "S" | "T" |
                   "U" | "V" | "W" | "X" | "Y" | "Z" |
                   "a" | "b" | "c" | "d" | "e" | "f" | "g" | "h" | "i" | "j" |
                   "k" | "l" | "m" | "n" | "o" | "p" | "q" | "r" | "s" | "t" |
                   "u" | "v" | "w" | "x" | "y" | "z" | "_" ;
digit            = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" ;
hexdigit         = digit | "A" | "B" | "C" | "D" | "E" | "F" |
                            "a" | "b" | "c" | "d" | "e" | "f" ;
octdigit         = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" ;
bindigit         = "0" | "1" ;

(* identificateurs *)
ident_head       = letter ;
ident_tail       = { letter | digit } ;
identifier       = ident_head , ident_tail ;

(* mots-clés réservés *)
keyword =
    "module" | "import" | "pub" | "struct" | "enum" | "union" | "type" |
    "fn" | "let" | "mut" | "const" | "static" | "as" | "where" |
    "if" | "else" | "while" | "for" | "in" | "loop" | "match" |
    "break" | "continue" | "return" | "true" | "false" | "nil" ;

(* séparateurs et commentaires *)
whitespace       = { " " | "\t" | "\r" | "\n" } ;
line_comment     = "//" , { ? any char except line break ? } , ( "\n" | EOF ) ;
block_comment    = "/*" , { block_comment | ? any char except "*/" ? } , "*/" ;
sep              = { whitespace | line_comment | block_comment } ;

(* littéraux numériques, avec séparateurs '_' autorisés *)
int_dec          = digit , { digit | "_" } ;
int_hex          = "0x" , hexdigit , { hexdigit | "_" } ;
int_oct          = "0o" , octdigit , { octdigit | "_" } ;
int_bin          = "0b" , bindigit , { bindigit | "_" } ;
int_lit          = ( int_hex | int_oct | int_bin | int_dec ) , [ int_suffix ] ;

int_suffix       = ":" , ( "i8" | "i16" | "i32" | "i64" | "isize"
                         | "u8" | "u16" | "u32" | "u64" | "usize" ) ;

float_core       = int_dec , [ "." , { digit | "_" } ] , [ exp_part ] |
                   "." , digit , { digit | "_" } , [ exp_part ] ;
exp_part         = ( "e" | "E" ) , [ "+" | "-" ] , digit , { digit | "_" } ;
float_suffix     = ":" , ( "f32" | "f64" ) ;
float_lit        = float_core , [ float_suffix ] ;

(* littéraux booléens et nil *)
bool_lit         = "true" | "false" ;
nil_lit          = "nil" ;

(* littéraux char et string, avec échappements standards *)
escape_char      = "\\" , ( "'" | "\"" | "\\" | "n" | "r" | "t" | "0" | "x" , hexdigit , hexdigit
                           | "u" , "{" , hexdigit , { hexdigit } , "}" ) ;
char_inner       = ? any char except "'" and "\" and line breaks ? | escape_char ;
char_lit         = "'" , char_inner , "'" ;

str_inner        = { ? any char except "\"" and "\" not forming invalid escape ? | escape_char } ;
string_lit       = "\"" , str_inner , "\"" ;

literal          = int_lit | float_lit | bool_lit | nil_lit | char_lit | string_lit ;

(* symboles *)
sym_dot          = "." ;
sym_comma        = "," ;
sym_colon        = ":" ;
sym_semi         = ";" ;
sym_arrow        = "->" ;
sym_fatarrow     = "=>" ;
sym_assign       = "=" ;
sym_op           = "+" | "-" | "*" | "/" | "%" | "!" |
                   "==" | "!=" | "<" | "<=" | ">" | ">=" |
                   "&&" | "||" | "&" | "|" | "^" | "~" |
                   "+=" | "-=" | "*=" | "/=" | "%=" | "&=" | "|=" | "^=" |
                   "<<" | ">>" | "<<=" | ">>=" ;
sym_path         = "::" ;
sym_range        = ".." | "..=" ;
sym_qmark        = "?" ;

lparen           = "(" ; rparen = ")" ;
lbrace           = "{" ; rbrace = "}" ;
lbrack           = "[" ; rbrack = "]" ;
lt               = "<" ; gt = ">" ;
CliPathToken     = ? chemin CLI (UTF-8 sans espaces) ? ;
CliValueToken    = ? argument CLI (UTF-8 sans espaces) ? ;

(* =============================== SYNTAXE ================================= *)

CompilationUnit  = sep , ModuleDecl , { TopItem } , sep , EOF ;

(* ----- Modules & imports ----- *)
ModuleDecl       = "module" , sep , ModulePath , sep , sym_semi , sep ;
ModulePath       = identifier , { sym_path , identifier } ;

TopItem          = sep , ( UseDecl | TypeItem | FnItem | ConstItem | StaticItem ) ;

UseDecl          = "import" , sep , UseTree , sep , sym_semi , sep ;
UseTree          = ModulePath , [ sym_path , "*" ] ;

(* ----- Visibilité ----- *)
Vis              = [ "pub" , sep ] ;

(* ----- Types ----- *)
TypeItem         = Vis , ( StructItem | EnumItem | UnionItem | TypeAlias ) ;

TypeAlias        = "type" , sep , identifier , [ GenericParams ] ,
                   sep , sym_assign , sep , Type , sep , sym_semi ;

StructItem       = "struct" , sep , identifier , [ GenericParams ] ,
                   sep , StructBody ;

StructBody       = lbrace , sep , [ FieldList ] , rbrace ;
FieldList        = Field , { sep , sym_comma , sep , Field } , [ sep , sym_comma , sep ] ;
Field            = Vis , identifier , sep , sym_colon , sep , Type ;

EnumItem         = "enum" , sep , identifier , [ GenericParams ] ,
                   sep , lbrace , sep , [ EnumVariants ] , rbrace ;
EnumVariants     = EnumVariant , { sep , sym_comma , sep , EnumVariant } ,
                   [ sep , sym_comma , sep ] ;
EnumVariant      = identifier , [ TupleTyList | StructBody ] ;
TupleTyList      = lparen , sep , [ Type , { sep , sym_comma , sep , Type } ,
                   [ sep , sym_comma , sep ] ] , rparen ;

UnionItem        = "union" , sep , identifier , [ GenericParams ] ,
                   sep , lbrace , sep , FieldList , rbrace ;

GenericParams    = lt , sep , TypeParam , { sep , sym_comma , sep , TypeParam } ,
                   [ sep , sym_comma , sep ] , gt ;
TypeParam        = identifier , [ sep , ":" , sep , TypeBounds ] ;
TypeBounds       = Type , { sep , "+" , sep , Type } ;

(* ----- Fonctions ----- *)
FnItem           = Vis , "fn" , sep , identifier , [ GenericParams ] ,
                   sep , ParamList , [ sep , "->" , sep , Type ] ,
                   [ WhereClause ] , sep , Block ;

ParamList        = lparen , sep , [ Param , { sep , sym_comma , sep , Param } ,
                   [ sep , sym_comma , sep ] ] , rparen ;
Param            = [ "mut" , sep ] , identifier , sep , sym_colon , sep , Type ;

WhereClause      = sep , "where" , sep , WherePred , { sep , sym_comma , sep , WherePred } ;
WherePred        = Type , sep , ":" , sep , TypeBounds ;

ConstItem        = Vis , "const" , sep , identifier , sep , sym_colon , sep , Type ,
                   sep , sym_assign , sep , Expr , sep , sym_semi ;
StaticItem       = Vis , "static" , sep , identifier , sep , sym_colon , sep , Type ,
                   sep , sym_assign , sep , Expr , sep , sym_semi ;

(* ----- Types (usage) ----- *)
Type             = FunctionType
                 | TupleType
                 | ArrayType
                 | SliceType
                 | PtrType
                 | RefType
                 | PathType
                 | PrimitiveType ;

PrimitiveType    = "i8" | "i16" | "i32" | "i64" | "isize"
                 | "u8" | "u16" | "u32" | "u64" | "usize"
                 | "f32" | "f64"
                 | "bool" | "char" | "str" | "void" ;

PathType         = TypePath ;
TypePath         = TypeSegment , { sym_path , TypeSegment } ;
TypeSegment      = identifier , [ GenericArgs ] ;
GenericArgs      = lt , sep , Type , { sep , sym_comma , sep , Type } ,
                   [ sep , sym_comma , sep ] , gt ;

TupleType        = lparen , sep , [ Type , { sep , sym_comma , sep , Type } ,
                   [ sep , sym_comma , sep ] ] , rparen ;

ArrayType        = lbrack , sep , Type , sep , sym_semi , sep , Expr , rbrack ;
SliceType        = lbrack , sep , Type , rbrack ;

PtrType          = "*" , sep , Type ;
RefType          = "&" , sep , [ "mut" , sep ] , Type ;

FunctionType     = "fn" , sep , lparen , sep ,
                   [ Type , { sep , sym_comma , sep , Type } ,
                     [ sep , sym_comma , sep ] ] , rparen ,
                   [ sep , "->" , sep , Type ] ;

(* ----- Blocs et instructions ----- *)
Block            = lbrace , sep , { Stmt } , rbrace ;

Stmt             = LocalLetStmt
                 | ItemStmt
                 | ExprStmt
                 | EmptyStmt ;

ItemStmt         = TypeItem | FnItem | ConstItem | StaticItem ;

LocalLetStmt     = "let" , sep , [ "mut" , sep ] , Pattern ,
                   [ sep , sym_colon , sep , Type ] ,
                   [ sep , sym_assign , sep , Expr ] ,
                   sep , sym_semi ;

ExprStmt         = Expr , [ sep , sym_semi ] , sep ;
EmptyStmt        = sym_semi , sep ;

Pattern          = "_" 
                 | LiteralPattern
                 | IdentifierPattern
                 | TuplePattern
                 | StructPattern
                 | TupleStructPattern
                 | RefPattern
                 | PathPattern ;
LiteralPattern   = literal ;
IdentifierPattern= [ "mut" , sep ] , identifier ;
RefPattern       = "&" , sep , [ "mut" , sep ] , Pattern ;
TuplePattern     = lparen , sep , [ Pattern , { sep , sym_comma , sep , Pattern } ,
                   [ sep , sym_comma , sep ] ] , rparen ;
StructPattern    = ExprPath , lbrace , sep ,
                   [ StructPatternFields ] , rbrace ;
StructPatternFields
                 = FieldPat , { sep , sym_comma , sep , FieldPat } ,
                   [ sep , sym_comma , sep ] ,
                   [ sep , StructPatternRest ]
                 | StructPatternRest ;
StructPatternRest= ".." ;
TupleStructPattern = ExprPath , TuplePattern ;
PathPattern      = ExprPath ;
FieldPat         = identifier , [ sep , ":" , sep , Pattern ] ;

(* ----- Expressions (précédence de plus fort au plus faible) ----- *)

Expr             = AssignExpr ;

AssignExpr       = RangeExpr ,
                   { sep ,
                     AssignOp ,
                     sep ,
                     AssignExpr } ;
AssignOp         = sym_assign | "+=" | "-=" | "*=" | "/=" | "%=" |
                   "&=" | "|=" | "^=" | "<<=" | ">>=" ;

RangeExpr        = LogicOrExpr
                 | RangeBounds ;
RangeBounds      = [ LogicOrExpr , sep ] , sym_range , [ sep , LogicOrExpr ] ;

LogicOrExpr      = LogicAndExpr ,
                   { sep , "||" , sep , LogicAndExpr } ;
LogicAndExpr     = BitOrExpr ,
                   { sep , "&&" , sep , BitOrExpr } ;
BitOrExpr        = BitXorExpr ,
                   { sep , "|" , sep , BitXorExpr } ;
BitXorExpr       = BitAndExpr ,
                   { sep , "^" , sep , BitAndExpr } ;
BitAndExpr       = EqualityExpr ,
                   { sep , "&" , sep , EqualityExpr } ;
EqualityExpr     = RelExpr ,
                   { sep , ( "==" | "!=" ) , sep , RelExpr } ;
RelExpr          = ShiftExpr ,
                   { sep , ( "<" | "<=" | ">" | ">=" ) , sep , ShiftExpr } ;
ShiftExpr        = AddExpr ,
                   { sep , ( "<<" | ">>" ) , sep , AddExpr } ;
AddExpr          = MulExpr ,
                   { sep , ( "+" | "-" ) , sep , MulExpr } ;
MulExpr          = CastExpr ,
                   { sep , ( "*" | "/" | "%" ) , sep , CastExpr } ;
CastExpr         = UnaryExpr ,
                   { sep , "as" , sep , Type } ;

UnaryExpr        = PostfixExpr
                 | ( "!" | "-" | "~" ) , sep , UnaryExpr
                 | "*" , sep , UnaryExpr
                 | "&" , sep , [ "mut" , sep ] , UnaryExpr ;

PostfixExpr      = PrimaryExpr ,
                   { PostfixSuffix } ;
PostfixSuffix    = sep , sym_qmark
                 | sep , CallSuffix
                 | sep , IndexSuffix
                 | sep , FieldSuffix ;
CallSuffix       = lparen , sep , [ ArgList ] , rparen ;
ArgList          = Expr , { sep , sym_comma , sep , Expr } ,
                   [ sep , sym_comma , sep ] ;
IndexSuffix      = lbrack , sep , Expr , sep , rbrack ;
FieldSuffix      = sym_dot , sep , identifier , [ GenericArgs ] ;

PrimaryExpr      = literal
                 | ExprPath
                 | TupleExpr
                 | ArrayExpr
                 | StructExpr
                 | Block
                 | IfExpr
                 | MatchExpr
                 | LoopExpr
                 | WhileExpr
                 | ForExpr
                 | BreakExpr
                 | ContinueExpr
                 | ReturnExpr
                 | ClosureExpr ;

ExprPath         = [ sym_path , sep ] , TypeSegment ,
                   { sep , sym_path , sep , TypeSegment } ;

TupleExpr        = lparen , sep ,
                   [ Expr , { sep , sym_comma , sep , Expr } ,
                     [ sep , sym_comma , sep ] ] ,
                   rparen ;

ArrayExpr        = lbrack , sep , [ ArrayElements ] , rbrack ;
ArrayElements    = ArrayRepeat | ArrayList ;
ArrayRepeat      = Expr , sep , sym_semi , sep , Expr ;
ArrayList        = Expr , { sep , sym_comma , sep , Expr } ,
                   [ sep , sym_comma , sep ] ;

StructExpr       = ExprPath , StructExprBody ;
StructExprBody   = lbrace , sep , [ StructExprMembers ] , rbrace ;
StructExprMembers= StructExprField , { sep , sym_comma , sep , StructExprField } ,
                   [ sep , sym_comma , sep ] ,
                   [ sep , StructExprRest ]
                 | StructExprRest ;
StructExprField  = identifier , [ sep , sym_colon , sep , Expr ] ;
StructExprRest   = ".." , sep , Expr ;

IfExpr           = "if" , sep , IfCond , sep , Block ,
                   [ sep , "else" , sep , ElseBranch ] ;
IfCond           = "let" , sep , Pattern , sep , sym_assign , sep , Expr
                 | Expr ;
ElseBranch       = IfExpr | Block ;

MatchExpr        = "match" , sep , Expr , sep ,
                   lbrace , sep , [ MatchArms ] , rbrace ;
MatchArms        = MatchArm , { sep , sym_comma , sep , MatchArm } ,
                   [ sep , sym_comma , sep ] ;
MatchArm         = PatternChoice , [ sep , "if" , sep , Expr ] ,
                   sep , sym_fatarrow , sep , MatchBody ;
PatternChoice    = Pattern , { sep , "|" , sep , Pattern } ;
MatchBody        = Block | Expr ;

LoopExpr         = "loop" , sep , Block ;
WhileExpr        = "while" , sep , WhileCond , sep , Block ;
WhileCond        = "let" , sep , Pattern , sep , sym_assign , sep , Expr
                 | Expr ;
ForExpr          = "for" , sep , Pattern , sep , "in" , sep , Expr , sep , Block ;

BreakExpr        = "break" , [ sep , Expr ] ;
ContinueExpr     = "continue" ;
ReturnExpr       = "return" , [ sep , Expr ] ;

ClosureExpr      = [ "async" , sep ] , [ "move" , sep ] ,
                   "|" , sep , [ ClosureParams ] , "|" ,
                   [ sep , "->" , sep , Type ] ,
                   sep , ClosureBody ;
ClosureParams    = ClosureParam , { sep , sym_comma , sep , ClosureParam } ,
                   [ sep , sym_comma , sep ] ;
ClosureParam     = [ "mut" , sep ] , Pattern ,
                   [ sep , sym_colon , sep , Type ] ;
ClosureBody      = Block | Expr ;

(* =============================== CLI ==================================== *)

CliLine          = sep , { GlobalOption , sep } , CliCommand , sep , EOF ;

GlobalOption     = VerboseOption
                 | QuietOption
                 | ColorOption ;

VerboseOption    = "-v" | "-vv" | "-vvv" | "--verbose" ;
QuietOption      = "-q" | "--quiet" ;
ColorOption      = "--color" , [ ColorAssign ] ;
ColorAssign      = ( sep | "=" ) , ColorValue ;
ColorValue       = "auto" | "always" | "never" ;

CliCommand       = CompileCommand
                 | RunCommand
                 | FmtCommand
                 | InspectCommand
                 | DisasmCommand
                 | ModulesCommand ;

CompileCommand   = "compile" ,
                   [ sep , SourceOperand ] ,
                   { sep , CompileOption } ;
SourceOperand    = PathArgument ;
CompileOption    = OutputOption
                 | OptimizeOption
                 | DebugOption
                 | AutoMkdirOption
                 | OverwriteOption
                 | TimeOption
                 | AutoOutOption ;
OutputOption     = ( "-o" | "--output" ) ,
                   ( sep , PathArgument | "=" , PathArgument ) ;
OptimizeOption   = "-O" | "--optimize" ;
DebugOption      = "--debug" ;
AutoMkdirOption  = "--mkdir" ;
OverwriteOption  = "--overwrite" ;
TimeOption       = "--time" ;
AutoOutOption    = "--auto" ;

RunCommand       = "run" ,
                   [ sep , ProgramOperand ] ,
                   { sep , RunOption } ,
                   [ sep , "--" , RunArguments ] ;
ProgramOperand   = PathArgument ;
RunOption        = AutoCompileOption
                 | OptimizeOption
                 | TimeOption ;
AutoCompileOption= "--auto-compile" ;
RunArguments     = ValueArgument , { sep , ValueArgument } ;

FmtCommand       = "fmt" ,
                   [ sep , SourceOperand ] ,
                   { sep , FmtOption } ;
FmtOption        = OutputOption
                 | InPlaceOption
                 | CheckOption ;
InPlaceOption    = "--in-place" ;
CheckOption      = "--check" ;

InspectCommand   = "inspect" ,
                   [ sep , PathArgument ] ,
                   { sep , InspectOption } ;
InspectOption    = "--summary"
                 | "--symbols"
                 | "--consts"
                 | "--hexdump"
                 | "--json"
                 | "--target"
                 | "--header"
                 | "--sections"
                 | "--strings"
                 | "--imports"
                 | "--exports"
                 | "--disasm"
                 | "--debug"
                 | "--meta"
                 | "--verify"
                 | "--size"
                 | "--deps"
                 | "--entry"
                 | "--dump-all" ;

DisasmCommand    = "disasm" ,
                   [ sep , PathArgument ] ,
                   { sep , DisasmOption } ;
DisasmOption     = OutputOption ;

ModulesCommand   = "modules" ,
                   { sep , ModulesOption } ;
ModulesOption    = "--json" ;

PathArgument     = "-" | CliPathToken ;
ValueArgument    = CliValueToken ;
