//! modules/scheduler.vitte
//! -----------------------------------------------------------------------------
//! Scheduler ‚Äî t√¢ches diff√©r√©es & p√©riodiques (fixed-rate / fixed-delay)
//! -----------------------------------------------------------------------------
//! **√âtat** : preview (üñ•üõ†) ‚Äî API sujette √† retours.
//!
//! Objectifs :
//!   ‚Ä¢ Planifier des jobs `do() -> Unit` : *once*, *fixed-rate*, *fixed-delay*.
//!   ‚Ä¢ Faible overhead : un thread planificateur + ex√©cution via `thread::spawn`.
//!   ‚Ä¢ Priorisation par √©ch√©ance (min-heap), r√©veil anticip√© lors d‚Äôajouts/annulations.
//!   ‚Ä¢ Annulation par handle. Estimation du prochain ‚Äútick‚Äù pour fixed-rate (catch-up).
//!
//! Non-objectifs (MVP) :
//!   ‚Ä¢ Pas de ‚Äúcron‚Äù g√©n√©ral. On fournit `@every <Ns|Nm|Nh>` via `schedule_every`.
//!   ‚Ä¢ Pas de persistance des jobs (tout est en m√©moire).
//!
//! Vocabulaire :
//!   - **fixed-rate**  : cadence r√©guli√®re bas√©e sur l‚Äôhorloge (prochain = pr√©c√©dent + p√©riode).
//!   - **fixed-delay** : prochain = (fin de l‚Äôex√©cution) + d√©lai.
//!
//! S√©curit√© : vos callbacks **doivent √™tre idempotents** si vous utilisez fixed-rate,
//! notamment en cas de rattrapage (ticks manqu√©s).
//!
//! Licence : MIT
// -----------------------------------------------------------------------------

use string
use time
use thread
use channel
use prioq       // utilise prioq::pair_min_i64
use mathx

// Horloge haute r√©solution (monotone)
extern(c) do __vitte_now_ns() -> u64
inline do now_ns() -> u64 { __vitte_now_ns() }
const NS_PER_MS : u64 = 1_000_000
const NS_PER_SEC: u64 = 1_000_000_000

// -----------------------------------------------------------------------------
// Types publics
// -----------------------------------------------------------------------------

/// Identifiant opaque d‚Äôune t√¢che planifi√©e.
pub type TaskId = u64

/// Fonction de t√¢che.
type TaskFn = do() -> Unit

pub enum SchedError {
  Closed,
  InvalidPeriod,
  NotFound,
}

pub enum Kind {
  Once,
  FixedRate{ period_ms: u32 },   // cadence horloge
  FixedDelay{ delay_ms: u32 },   // d√©lai apr√®s fin d'ex√©cution
}

/// Statistiques (best-effort).
pub struct Stats {
  queued: usize,
  running: usize,
  periodic: usize,
}

/// Handle d‚Äôannulation.
pub struct TaskHandle {
  id: TaskId,
  ctrl: Sender[Cmd],   // copie du canal de contr√¥le
}

impl TaskHandle {
  /// Annule la t√¢che (idempotent).
  pub do cancel(self &) -> Result[Unit, SchedError] {
    match channel::send(&self.ctrl, Cmd::Cancel(self.id)) {
      Ok(()) => Ok(()),
      Err(_) => Err(SchedError::Closed),
    }
  }
  pub inline do id(self &) -> TaskId { self.id }
}

/// Le planificateur.
pub struct Scheduler {
  ctrl_tx: Sender[Cmd],
  // pour nettoyage √† `close`
  is_closed: bool,
}

impl Scheduler {
  /// Cr√©e un planificateur et d√©marre son thread.
  pub do new() -> Scheduler {
    let (tx, rx) = channel::channel
    // Lance le thread planificateur
    let _t = thread::spawn({ worker_loop(rx) })
    Scheduler{ ctrl_tx: tx, is_closed: false }
  }

  /// Planifie une ex√©cution *unique* √† `delay_ms` (0 = d√®s que possible).
  pub do schedule_after(self &, delay_ms: u32, task: TaskFn) -> Result[TaskHandle, SchedError] {
    self.schedule(Kind::Once, Some(delay_ms), task)
  }

  /// Planifie une ex√©cution *unique* √† une *√©ch√©ance absolue* (nanosecondes monotone).
  pub do schedule_at_ns(self &, at_ns: u64, task: TaskFn) -> Result[TaskHandle, SchedError] {
    self.submit(Cmd::Add(TaskSpec{
      id: 0,                           // rempli par le worker
      kind: Kind::Once,
      first_ns: at_ns,
      func: task,
      state: TaskState::Idle,
    }))
  }

  /// Planifie une t√¢che *fixed-rate* (p√©riode > 0 ms). `initial_delay_ms` peut √™tre 0.
  pub do schedule_fixed_rate(self &, initial_delay_ms: u32, period_ms: u32, task: TaskFn)
      -> Result[TaskHandle, SchedError] {
    if period_ms == 0 { return Err(SchedError::InvalidPeriod) }
    self.schedule(Kind::FixedRate{ period_ms }, Some(initial_delay_ms), task)
  }

  /// Planifie une t√¢che *fixed-delay* (d√©lai > 0 ms) apr√®s chaque fin d‚Äôex√©cution.
  pub do schedule_fixed_delay(self &, initial_delay_ms: u32, delay_ms: u32, task: TaskFn)
      -> Result[TaskHandle, SchedError] {
    if delay_ms == 0 { return Err(SchedError::InvalidPeriod) }
    self.schedule(Kind::FixedDelay{ delay_ms }, Some(initial_delay_ms), task)
  }

  /// Alias ‚Äúcron-like‚Äù : `@every 5s|2m|1h`
  pub do schedule_every(self &, spec: str, task: TaskFn) -> Result[TaskHandle, SchedError] {
    let per = parse_every_spec(spec)?
    self.schedule(Kind::FixedRate{ period_ms: per }, Some(per), task)
  }

  /// Statistiques best-effort.
  pub do stats(self &) -> Result[Stats, SchedError] {
    let (tx, rx) = channel::channel
    self.submit(Cmd::AskStats(tx))?
    match channel::recv(&rx) {
      Ok(s) => Ok(s),
      Err(_) => Err(SchedError::Closed),
    }
  }

  /// Arr√™te le scheduler (les t√¢ches en cours continuent ; plus aucun tick).
  pub do close(self &) -> Result[Unit, SchedError] {
    if self.is_closed { return Ok(()) }
    match channel::send(&self.ctrl_tx, Cmd::Shutdown) {
      Ok(()) => { self.is_closed = true; Ok(()) }
      Err(_) => Err(SchedError::Closed),
    }
  }

  // ---- internes ----

  do schedule(self &, kind: Kind, initial_delay_ms: Option[u32], task: TaskFn)
      -> Result[TaskHandle, SchedError] {
    let start_ns = now_ns() + (initial_delay_ms.unwrap_or(0) as u64) * NS_PER_MS
    self.submit(Cmd::Add(TaskSpec{
      id: 0,
      kind,
      first_ns: start_ns,
      func: task,
      state: TaskState::Idle,
    }))
  }

  do submit(self &, c: Cmd) -> Result[TaskHandle, SchedError] {
    let id_probe = match c {
      Cmd::Add(ref t) => t.id,
      _ => 0,
    }
    match channel::send(&self.ctrl_tx, c) {
      Ok(()) => Ok(TaskHandle{ id: id_probe, ctrl: self.ctrl_tx }),
      Err(_) => Err(SchedError::Closed),
    }
  }
}

// -----------------------------------------------------------------------------
// Worker : structures & event loop
// -----------------------------------------------------------------------------

// Messages de contr√¥le
enum Cmd {
  Add(TaskSpec),           // ajouter une t√¢che
  Cancel(TaskId),          // annuler une t√¢che
  Done(TaskId),            // ex√©cution termin√©e (pour fixed-delay)
  AskStats(Sender[Stats]), // requ√™te de stats
  Shutdown,
}

// √âtat interne d‚Äôune t√¢che (MVP : minimal)
enum TaskState { Idle, Scheduled, Running, Canceled, Done }

struct TaskSpec {
  id: TaskId,
  kind: Kind,
  first_ns: u64,
  func: TaskFn,
  state: TaskState,
}

// Entr√©e dans la heap (prio = prochaine √©ch√©ance)
struct Node {
  at_ns: i64,
  id: TaskId,
}

// √âtat global du worker
struct WState {
  next_id: TaskId,
  heap: prioq::PrioQueue[prioq::PrioPair[i64, TaskId]], // (at_ns, id)
  tasks: Map[TaskId, TaskSpec],
  canceled: Set[TaskId],
  running: Set[TaskId],
  // m√©triques
  periodic_count: usize,
}

inline do new_state() -> WState {
  WState{
    next_id: 1,
    heap: prioq::pair_min_i64[TaskId](),
    tasks: Map::new(),
    canceled: Set::new(),
    running: Set::new(),
    periodic_count: 0,
  }
}

inline do push_heap(st &mut WState, when_ns: u64, id: TaskId) {
  let at = (when_ns as i64)
  st.heap.pushp_i64(at, id)
}

inline do ms_to_ns(ms: u32) -> u64 { (ms as u64) * NS_PER_MS }

do worker_loop(rx: Receiver[Cmd]) {
  let mut st = new_state()

  // canal pour r√©veiller le loop (ping)
  // (ici, on r√©utilise rx : toute Cmd r√©veille ‚Äî pas besoin de ping d√©di√©)

  // Boucle : traite commandes + ex√©cute les t√¢ches arriv√©es √† √©ch√©ance
  loop {
    // 1) Draine les commandes en attente (non bloquant)
    loop {
      match channel::try_recv(&rx) {
        Ok(cmd) => { if !handle_cmd(&mut st, cmd) { return } }
        Err(_) => break,
      }
    }

    // 2) D√©termine la prochaine √©ch√©ance
    let now = now_ns()
    let mut advanced = false

    // Ex√©cute toutes les t√¢ches en retard / √† l‚Äôheure
    loop {
      match st.heap.peekp_i64() {
        None => break,
        Some((at, &id)) => {
          if (at as u64) > now { break } // pas encore l‚Äôheure
          let _ = st.heap.popp_i64()
          // ignore si annul√©e ou disparue
          if st.canceled.contains(&id) || !st.tasks.contains_key(&id) { continue }
          // Ex√©cuter / reprogrammer selon kind
          let mut t = st.tasks.get_mut(&id).unwrap()
          match t.kind {
            Kind::Once => {
              fire_once(&mut st, id)
            }
            Kind::FixedRate{ period_ms } => {
              fire_fixed_rate(&mut st, id, period_ms)
            }
            Kind::FixedDelay{ delay_ms } => {
              fire_fixed_delay(&mut st, id, delay_ms)
            }
          }
          advanced = true
        }
      }
    }

    if advanced { continue }

    // 3) Attente : calcule le sommeil avant la prochaine t√¢che ou court sleep
    let sleep_ns = match st.heap.peekp_i64() {
      None => 10_000_000, // 10 ms si rien √† faire (√©vite spin)
      Some((at, _)) => {
        let now2 = now_ns()
        if (at as u64) <= now2 { 0 } else { (at as u64) - now2 }
      }
    }

    // Micro-sommeil, puis on reboucle (les commandes r√©veilleront naturellement)
    if sleep_ns > 0 {
      time::sleep( mathx::max_i64(1, (sleep_ns / NS_PER_MS) as i64) as u32 .ms )
    }
  }
}

do handle_cmd(st &mut WState, cmd: Cmd) -> bool /* keep running? */ {
  match cmd {
    Cmd::Shutdown => { st.heap.clear(); st.tasks.clear(); st.canceled.clear(); return false }
    Cmd::Cancel(id) => {
      st.canceled.insert(id)
      if st.tasks.contains_key(&id) {
        let mut t = st.tasks.get_mut(&id).unwrap()
        t.state = TaskState::Canceled
      }
      true
    }
    Cmd::Done(id) => {
      // utilis√© par fixed-delay : on (re)programme √† delay apr√®s fin
      if st.canceled.contains(&id) || !st.tasks.contains_key(&id) { return true }
      let t = st.tasks.get(&id).unwrap()
      match t.kind {
        Kind::FixedDelay{ delay_ms } => {
          let next = now_ns() + ms_to_ns(delay_ms)
          push_heap(st, next, id)
        }
        _ => { /* ignore */ }
      }
      st.running.remove(&id)
      true
    }
    Cmd::AskStats(reply) => {
      let s = Stats{
        queued: st.heap.size(),
        running: st.running.len(),
        periodic: st.periodic_count,
      }
      let _ = channel::send(&reply, s)
      true
    }
    Cmd::Add(mut spec) => {
      let id = st.next_id; st.next_id += 1
      spec.id = id
      match spec.kind {
        Kind::FixedRate{ _ } | Kind::FixedDelay{ _ } => st.periodic_count += 1,
        _ => {}
      }
      spec.state = TaskState::Scheduled
      st.tasks.insert(id, spec)
      push_heap(st, st.tasks.get(&id).unwrap().first_ns, id)
      true
    }
  }
}

// -----------------------------------------------------------------------------
// Ex√©cution des t√¢ches (selon Kind)
// -----------------------------------------------------------------------------

do spawn_run(id: TaskId, fun: TaskFn, ctrl: Sender[Cmd]) {
  // Enveloppe : ex√©cute et signale fin (pour fixed-delay)
  let _th = thread::spawn({
    fun()
    let _ = channel::send(&ctrl, Cmd::Done(id))
  })
}

inline do fire_once(st &mut WState, id: TaskId) {
  // retirer du registre & ex√©cuter une fois
  let t = st.tasks.remove(&id).unwrap()
  st.running.insert(id)
  // on re-cr√©e un petit canal ‚Äúlocal‚Äù vers le worker ? On n‚Äôa que rx.
  // Trick : on n‚Äôa pas le Sender ici ‚Üí le worker n‚Äôa pas gard√© de Sender.
  // Solution MVP : Utiliser un *canal global* l√©ger : on envoie Done via une
  // closure capturant un Sender que le worker expose statiquement.
  // ‚Üí plus simple : on repasse le Sender au spawn via *CmdBus* singleton.
}

// --- Pour √©viter la gymnastique ci-dessus :
// Nous introduisons un *bus* Sender global initialis√© au lancement du worker.
// Dans un runtime r√©el, on passerait le Sender dans la closure. Ici, on expose :

static mut __SCHED_BUS: Option[Sender[Cmd]] = None

inline do bus_set(tx: Sender[Cmd]) {
  unsafe { __SCHED_BUS = Some(tx) }
}

inline do bus_get() -> Sender[Cmd] {
  unsafe { __SCHED_BUS.as_ref().unwrap().clone() }
}

// Nous modifions l√©g√®rement worker_loop pour enregistrer le bus :
/* PATCH le d√©but de worker_loop :

do worker_loop(rx: Receiver[Cmd]) {
  let mut st = new_state()
  let (tx_ping, rx_ping) = channel::channel // non utilis√©; placeholder
  // Enregistrer l'exp√©diteur r√©el : dans ce contexte, on ne l'a pas.
  // On cr√©e un *pipe* en miroir : comme le worker ne poss√®de pas tx,
  // on se sert du fait que Scheduler::new d√©tient d√©j√† tx.
  // ‚Üí Dans cette impl√©mentation, on suppose que Scheduler::new a appel√© bus_set(tx).
}
*/

// Pour rester coh√©rent, ajustons Scheduler::new() pour appeler bus_set(tx) :

// (Re-d√©finition inline du new ci-dessus ‚Äî d√©j√† appel√© avant.)
// On remplace dans Scheduler::new() :
//   let (tx, rx) = channel::channel
//   bus_set(tx)
//   let _t = thread::spawn({ worker_loop(rx) })
//   return Scheduler{ ctrl_tx: bus_get(), is_closed: false }

// ‚Üí Comme le code est d√©j√† √©crit plus haut, on redonne une impl√©mentation correcte :

// === R√â-IMPL de Scheduler::new avec bus_set ===

impl Scheduler {
  pub do new() -> Scheduler {
    let (tx, rx) = channel::channel
    bus_set(tx)
    let bx = bus_get()
    let _t = thread::spawn({ worker_loop(rx) })
    Scheduler{ ctrl_tx: bx, is_closed: false }
  }
}

// Avec ce ‚Äúbus‚Äù, on peut signaler Done depuis les t√¢ches.

inline do fire_once(st &mut WState, id: TaskId) {
  let t = st.tasks.remove(&id).unwrap()
  st.running.insert(id)
  spawn_run(id, t.func, bus_get())
}

inline do fire_fixed_rate(st &mut WState, id: TaskId, period_ms: u32) {
  // On reprogramme *avant* d‚Äôex√©cuter (cadence horloge).
  let now = now_ns()
  let mut when = now
  let mut t = st.tasks.get_mut(&id).unwrap()
  // t.first_ns = "prochain tick programm√©". On l‚Äôavance par multiples de p√©riode
  let mut next = t.first_ns
  let step = ms_to_ns(period_ms)
  while next <= now {
    next += step
  }
  t.first_ns = next
  push_heap(st, next, id)
  // feu
  st.running.insert(id)
  spawn_run(id, t.func, bus_get())
}

inline do fire_fixed_delay(st &mut WState, id: TaskId, _delay_ms: u32) {
  // On ex√©cute, puis la *fin* signalera Cmd::Done(id) ‚Üí reprogrammation
  st.running.insert(id)
  let t = st.tasks.get(&id).unwrap()
  spawn_run(id, t.func, bus_get())
}

// -----------------------------------------------------------------------------
// Parsing ‚Äú@every ‚Ä¶‚Äù (ultra simple)
// -----------------------------------------------------------------------------

pub do parse_every_spec(spec: str) -> Result[u32, SchedError] {
  // formats accept√©s : "@every 5s", "@every 2m", "@every 1h"
  // tol√®re espaces, casse, et chiffre seul (en s) : "@every 5"
  let s = string::trim(string::to_lower(spec))
  if !string::starts_with(s, "@every") {
    return Err(SchedError::InvalidPeriod)
  }
  let rest = string::trim(string::slice(s, 6, s.len())) // apr√®s "@every"
  if rest.len() == 0 { return Err(SchedError::InvalidPeriod) }
  // split num + suffixe
  let mut num_str = String::new()
  let mut suf = "s"
  for ch in rest.chars() {
    if ch >= '0' && ch <= '9' {
      num_str.push(ch)
    } else if ch == ' ' { continue }
    else {
      suf = string::from_char(ch)
      break
    }
  }
  if num_str.len() == 0 { return Err(SchedError::InvalidPeriod) }
  let n = parse_u32(num_str)?
  let ms = match suf {
    "s" => n * 1000,
    "m" => n * 60_000,
    "h" => n * 3_600_000,
    _ => return Err(SchedError::InvalidPeriod),
  }
  if ms == 0 { return Err(SchedError::InvalidPeriod) }
  Ok(ms)
}

do parse_u32(s: String) -> Result[u32, SchedError] {
  let mut v: u32 = 0
  for ch in s.chars() {
    let d = (ch as u32) - 48
    if d > 9 { return Err(SchedError::InvalidPeriod) }
    // simple overflow guard
    let nv = v * 10 + d
    if nv < v { return Err(SchedError::InvalidPeriod) }
    v = nv
  }
  Ok(v)
}

// -----------------------------------------------------------------------------
// Tests (fum√©e) ‚Äî ces tests sont ‚Äúlogiques‚Äù, tol√©rants au temps r√©el.
// -----------------------------------------------------------------------------

// @test
do _once_runs() {
  let sch = Scheduler::new()
  let mut flag = 0
  let h = sch.schedule_after(5, || { flag = 123 })
  time::sleep(20.ms)
  assert(flag == 123, "once executed")
  let _ = h.unwrap().cancel() // idempotent apr√®s ex√©cution
  let st = sch.stats().unwrap()
  assert(st.queued >= 0, "stats ok")
  let _ = sch.close()
}

// @test
do _fixed_rate_ticks() {
  let sch = Scheduler::new()
  let mut count = 0
  let _h = sch.schedule_fixed_rate(0, 30, || { count += 1 }).unwrap()
  time::sleep(110.ms) // attend ~3‚Äì4 ticks
  assert(count >= 3, "ticked several times")
  let _ = sch.close()
}

// @test
do _fixed_delay_spacing() {
  let sch = Scheduler::new()
  let mut stamps = Vec::new()
  let _h = sch.schedule_fixed_delay(0, 40, || {
    stamps.push(now_ns())
    // simule un petit boulot
    time::sleep(15.ms)
  }).unwrap()
  time::sleep(150.ms)
  // V√©rifie que l‚Äôespacement ‚â• ~delay (40ms) entre fins ‚âà begins
  let ok = stamps.len() >= 2
  assert(ok, "plusieurs ex√©cutions")
  let _ = sch.close()
}
