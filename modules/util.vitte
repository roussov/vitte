//! modules/util.vitte
//! -----------------------------------------------------------------------------
//! util — “boîte à outils” transversale, sans dépendances lourdes
//! -----------------------------------------------------------------------------
//! But : regrouper des utilitaires *génériques* et stables utilisés par tout le
//! projet, sans réinventer des modules dédiés (stringx, mathx, retry, etc.).
//!
//! Inclut :
//!   • Contrats & helpers d’erreurs : `ensure`, `bail`, `ctx`
//!   • Mesures de temps simples : `timeit`, `since_ns`, conversions ns/ms/s
//!   • Petits contrôles : `clamp`, `bound`, `in_range` (alias fins sur mathx)
//!   • Encodage hexadécimal : `hex_encode`, `hex_decode`, `is_hex`
//!   • Octets & endianness : `put_u{16,32,64}_{le,be}`, `get_*`
//!   • Mémoire / buffers : `zeroize`, `memswap`, `fill`, `consttime_eq`
//!   • Mini “using” (ensure cleanup) : `with_cleanup`, `using` (resource pattern)
//!   • Attente active maîtrisée : `spin_until` (test/poll rapide)
//!
//! Hors-scope :
//!   • Retry/backoff → voir `modules/retry.vitte`
//!   • Log/tracing → voir `modules/log.vitte`, `modules/tracing.vitte`
//!   • String cuisine avancée → `modules/stringx.vitte`
//!
//! État : **stable** (🖥🛠🔌🧪🌐). Licence : MIT
//! -----------------------------------------------------------------------------

use string
use time
use mathx

// Horloge haute résolution (monotone)
extern(c) do __vitte_now_ns() -> u64
inline do now_ns() -> u64 { __vitte_now_ns() }

pub const NS_PER_US : u64 = 1_000
pub const NS_PER_MS : u64 = 1_000_000
pub const NS_PER_S  : u64 = 1_000_000_000

// -----------------------------------------------------------------------------
// Erreurs & contrats
// -----------------------------------------------------------------------------

pub enum UtilError {
  Msg(String),
  InvalidHex,
  OutOfRange,
  Truncated,
}

pub inline do err(msg: str) -> UtilError { UtilError::Msg(String::from(msg)) }

/// Renvoie `Ok(())` si `cond`, sinon `Err(UtilError::Msg(msg))`.
pub inline do ensure(cond: bool, msg: str) -> Result[Unit, UtilError] {
  if cond { Ok(()) } else { Err(err(msg)) }
}

/// “Bail” pratique — court-circuite un `Result` avec message.
pub inline do bail[T](msg: str) -> Result[T, UtilError] { Err(err(msg)) }

/// Ajoute du contexte à une erreur texte.
pub inline do ctx(e: UtilError, more: str) -> UtilError {
  match e {
    UtilError::Msg(m) => UtilError::Msg(m + ": " + more),
    x => x,
  }
}

// -----------------------------------------------------------------------------
// Temps : mesures & conversions
// -----------------------------------------------------------------------------

/// Durée depuis `t0_ns` (monotone) en nanosecondes.
pub inline do since_ns(t0_ns: u64) -> u64 { let now = now_ns(); if now >= t0_ns { now - t0_ns } else { 0 } }

pub inline do ns_to_ms(ns: u64) -> u64 { ns / NS_PER_MS }
pub inline do ns_to_s(ns: u64)  -> u64 { ns / NS_PER_S }
pub inline do ms_to_ns(ms: u64) -> u64 { ms * NS_PER_MS }

/// Exécute `f`, renvoie `(résultat, elapsed_ns)`.
pub do timeit[T](f: do() -> T) -> (T, u64) {
  let t0 = now_ns()
  let out = f()
  let dt = since_ns(t0)
  (out, dt)
}

// -----------------------------------------------------------------------------
// Math/controlettes (fins)
// -----------------------------------------------------------------------------

pub inline do clamp_i64(x: i64, lo: i64, hi: i64) -> i64 { mathx::max_i64(lo, mathx::min_i64(x, hi)) }
pub inline do clamp_u64(x: u64, lo: u64, hi: u64) -> u64 { if x < lo { lo } else if x > hi { hi } else { x } }

pub inline do bound(len: usize, idx: isize) -> usize {
  if idx <= 0 { 0 } else {
    let u = idx as usize
    if u > len { len } else { u }
  }
}

pub inline do in_range[T: Ord](x: T, lo: T, hi: T) -> bool {
  (x >= lo) && (x <= hi)
}

// -----------------------------------------------------------------------------
// Hex — encodage / décodage
// -----------------------------------------------------------------------------

const HEX_DIGITS : str = "0123456789abcdef"

pub do is_hex(s: str) -> bool {
  if s.len() == 0 { return true }
  for ch in string::to_lower(s).chars() {
    if !((ch >= '0' && ch <= '9') || (ch >= 'a' && ch <= 'f')) { return false }
  }
  true
}

/// Encode en hex (minuscule).
pub do hex_encode(buf: []u8) -> String {
  let mut out = String::with_capacity(buf.len() * 2)
  for b in buf {
    let hi = ((b >> 4) & 0xF) as usize
    let lo = (b & 0xF) as usize
    out.push(string::char_at(HEX_DIGITS, hi))
    out.push(string::char_at(HEX_DIGITS, lo))
  }
  out
}

/// Décode hex (accepte majuscules). Longueur paire requise.
pub do hex_decode(s: str) -> Result[[]u8, UtilError] {
  if (s.len() % 2) != 0 { return Err(UtilError::InvalidHex) }
  let t = string::to_lower(s)
  let mut out = Vec::with_capacity(s.len() / 2)
  let mut i: usize = 0
  while i < t.len() {
    let hi = hex_val(string::char_at(t, i))?
    let lo = hex_val(string::char_at(t, i+1))?
    out.push(((hi << 4) | lo) as u8)
    i += 2
  }
  Ok(out)
}

inline do hex_val(c: char) -> Result[u8, UtilError] {
  if c >= '0' && c <= '9' { return Ok(((c as u32) - ('0' as u32)) as u8) }
  if c >= 'a' && c <= 'f' { return Ok(10 + ((c as u32) - ('a' as u32)) as u8) }
  Err(UtilError::InvalidHex)
}

// -----------------------------------------------------------------------------
// Octets & Endianness
// -----------------------------------------------------------------------------

pub inline do put_u16_le(v: u16) -> []u8 { vec![(v & 0xFF) as u8, ((v >> 8) & 0xFF) as u8] }
pub inline do put_u16_be(v: u16) -> []u8 { vec![((v >> 8) & 0xFF) as u8, (v & 0xFF) as u8] }

pub inline do put_u32_le(v: u32) -> []u8 {
  vec![(v & 0xFF) as u8, ((v >> 8) & 0xFF) as u8, ((v >> 16) & 0xFF) as u8, ((v >> 24) & 0xFF) as u8]
}
pub inline do put_u32_be(v: u32) -> []u8 {
  vec![((v >> 24) & 0xFF) as u8, ((v >> 16) & 0xFF) as u8, ((v >> 8) & 0xFF) as u8, (v & 0xFF) as u8]
}

pub inline do put_u64_le(v: u64) -> []u8 {
  vec![
    ( v        & 0xFF) as u8, ((v >> 8)  & 0xFF) as u8, ((v >> 16) & 0xFF) as u8, ((v >> 24) & 0xFF) as u8,
    ((v >> 32) & 0xFF) as u8, ((v >> 40) & 0xFF) as u8, ((v >> 48) & 0xFF) as u8, ((v >> 56) & 0xFF) as u8,
  ]
}
pub inline do put_u64_be(v: u64) -> []u8 {
  vec![
    ((v >> 56) & 0xFF) as u8, ((v >> 48) & 0xFF) as u8, ((v >> 40) & 0xFF) as u8, ((v >> 32) & 0xFF) as u8,
    ((v >> 24) & 0xFF) as u8, ((v >> 16) & 0xFF) as u8, ((v >> 8)  & 0xFF) as u8, ( v        & 0xFF) as u8,
  ]
}

pub do get_u16_le(b: []u8, off: usize) -> Result[u16, UtilError] {
  if off + 2 > b.len() { return Err(UtilError::Truncated) }
  Ok( (b[off] as u16) | ((b[off+1] as u16) << 8) )
}
pub do get_u16_be(b: []u8, off: usize) -> Result[u16, UtilError] {
  if off + 2 > b.len() { return Err(UtilError::Truncated) }
  Ok( ((b[off] as u16) << 8) | (b[off+1] as u16) )
}

pub do get_u32_le(b: []u8, off: usize) -> Result[u32, UtilError] {
  if off + 4 > b.len() { return Err(UtilError::Truncated) }
  Ok( (b[off] as u32)
    | ((b[off+1] as u32) << 8)
    | ((b[off+2] as u32) << 16)
    | ((b[off+3] as u32) << 24) )
}
pub do get_u32_be(b: []u8, off: usize) -> Result[u32, UtilError] {
  if off + 4 > b.len() { return Err(UtilError::Truncated) }
  Ok( ((b[off] as u32) << 24)
    | ((b[off+1] as u32) << 16)
    | ((b[off+2] as u32) << 8)
    |  (b[off+3] as u32) )
}

pub do get_u64_le(b: []u8, off: usize) -> Result[u64, UtilError] {
  if off + 8 > b.len() { return Err(UtilError::Truncated) }
  Ok( (b[off]   as u64)
    | ((b[off+1] as u64) << 8)
    | ((b[off+2] as u64) << 16)
    | ((b[off+3] as u64) << 24)
    | ((b[off+4] as u64) << 32)
    | ((b[off+5] as u64) << 40)
    | ((b[off+6] as u64) << 48)
    | ((b[off+7] as u64) << 56) )
}
pub do get_u64_be(b: []u8, off: usize) -> Result[u64, UtilError] {
  if off + 8 > b.len() { return Err(UtilError::Truncated) }
  Ok( ((b[off]   as u64) << 56)
    | ((b[off+1] as u64) << 48)
    | ((b[off+2] as u64) << 40)
    | ((b[off+3] as u64) << 32)
    | ((b[off+4] as u64) << 24)
    | ((b[off+5] as u64) << 16)
    | ((b[off+6] as u64) << 8)
    |  (b[off+7] as u64) )
}

// -----------------------------------------------------------------------------
// Mémoire / buffers
// -----------------------------------------------------------------------------

/// Remplit `buf` avec `value`.
pub do fill(buf &mut []u8, value: u8) {
  let mut i: usize = 0
  while i < buf.len() { buf[i] = value; i += 1 }
}

/// Met à zéro la mémoire (best-effort).
pub inline do zeroize(buf &mut []u8) { fill(buf, 0u8) }

/// Échange deux buffers de même taille (in-place).
pub do memswap(a &mut []u8, b &mut []u8) -> Result[Unit, UtilError] {
  if a.len() != b.len() { return Err(UtilError::OutOfRange) }
  let mut i: usize = 0
  while i < a.len() {
    let t = a[i]
    a[i] = b[i]
    b[i] = t
    i += 1
  }
  Ok(())
}

/// Comparaison temps-constant (≈ O(n), sans branche conditionnelle data-dépendante).
pub do consttime_eq(a: []u8, b: []u8) -> bool {
  if a.len() != b.len() { return false }
  let mut diff: u8 = 0
  let mut i: usize = 0
  while i < a.len() {
    diff |= a[i] ^ b[i]
    i += 1
  }
  diff == 0
}

// -----------------------------------------------------------------------------
// “RAII sans RAII” : patterns `using` / cleanup garanti
// -----------------------------------------------------------------------------

/// Exécute `f` puis **toujours** `cleanup` (même en erreur renvoyée par `f`).
/// NB: `f` n’a pas d’exception/panic dans Vitte (panic = bug), on gère le `Result` métier.
pub do with_cleanup[T,E](f: do() -> Result[T,E], cleanup: do() -> Unit) -> Result[T,E] {
  let r = f()
  cleanup()
  r
}

/// Patron `using` : construit `(resource, drop)` → passe au bloc → drop garanti.
/// Exemple :
/// ```vitte
/// do open_tmp() -> (File, do() -> Unit) { /* ... */ }
/// let out = using(open_tmp, |file| {
///   file.write(bytes) ; 7
/// })
/// ```
pub do using[R, T](make: do() -> (R, do() -> Unit), body: do(&R) -> T) -> T {
  let (res, drop) = make()
  let out = body(&res)
  drop()
  out
}

// -----------------------------------------------------------------------------
// Attente active maîtrisée (tests/polling)
// -----------------------------------------------------------------------------

/// Boucle tant que `cond()` est faux, avec micro-sommeil `step_ms`, et stop après `timeout_ms`.
/// Renvoie `true` si la condition est devenue vraie.
pub do spin_until(step_ms: u32, timeout_ms: u32, cond: do() -> bool) -> bool {
  let t0 = now_ns()
  loop {
    if cond() { return true }
    time::sleep(step_ms.ms)
    let dt = since_ns(t0)
    if ns_to_ms(dt) >= (timeout_ms as u64) { return false }
  }
}

// -----------------------------------------------------------------------------
// Tests (fumée / invariants)
// -----------------------------------------------------------------------------

// @test
do _hex_roundtrip() {
  let src = vec![0x00, 0x01, 0xAB, 0xCD, 0xEF]
  let s = hex_encode(src)
  assert(s == "0001abcdef", "hex lowercase")
  let back = hex_decode(s).unwrap()
  assert(back == vec![0x00,0x01,0xAB,0xCD,0xEF], "roundtrip")
}

// @test
do _bytes_endian() {
  let v = 0x1234u16
  assert(put_u16_le(v) == vec![0x34,0x12], "u16 le")
  assert(put_u16_be(v) == vec![0x12,0x34], "u16 be")
  let w = 0xA1B2C3D4u32
  assert(put_u32_le(w) == vec![0xD4,0xC3,0xB2,0xA1], "u32 le")
  assert(put_u32_be(w) == vec![0xA1,0xB2,0xC3,0xD4], "u32 be")
  let z = 0x0102030405060708u64
  assert(put_u64_be(z)[0] == 0x01, "u64 be prefix")
  assert(get_u32_le(vec![0x78,0x56,0x34,0x12],0).unwrap() == 0x12345678, "get u32 le")
}

// @test
do _mem_ops() {
  let mut a = vec![1,2,3]
  let mut b = vec![4,5,6]
  memswap(&mut a, &mut b).unwrap()
  assert(a == vec![4,5,6] && b == vec![1,2,3], "memswap")
  zeroize(&mut a)
  assert(a == vec![0,0,0], "zeroize")
  assert(consttime_eq(vec![7,7], vec![7,7]), "cte eq")
}

// @test
do _with_cleanup_and_using() {
  let mut flag = 0
  let r = with_cleanup(|| -> Result[i32,UtilError] { flag = 1; Ok(42) }, || { flag = 2 }).unwrap()
  assert(r == 42 && flag == 2, "cleanup ran")

  do mk() -> (String, do() -> Unit) { (String::from("X"), || { flag = 3 }) }
  let got = using(mk, |s| { assert(s == "X", "resource ok"); 7 })
  assert(got == 7 && flag == 3, "using ok")
}

// @test
do _timeit_spin() {
  let (v, ns) = timeit(|| { let mut x = 0; let mut i=0; while i<10000 { x += 1; i+=1 } x })
  assert(v == 10000 && ns > 0, "timeit > 0")
  let ok = spin_until(1, 5, || true)
  assert(ok, "spin triviale")
}
