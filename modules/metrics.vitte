//! modules/metrics.vitte
//! -------------------------------------------------------------
//! Metrics ‚Äî compteurs, jauges, histogrammes, timers & export Prometheus
//! -------------------------------------------------------------
//! Objectifs : API simple, sans allocs cach√©es, labels stables, export texte.
//! √âtat : preview (üñ•üõ†üåê) ‚Äî thread-safety d√©pendante de l‚Äôimpl. de Mutex/RwLock dans le core.
//!
//! Types fournis
//!   - Counter    (monotone, add-only, f64 pour compat Prometheus)
//!   - Gauge      (set/Inc/Dec, f64)
//!   - Histogram  (buckets cumul√©s, sum, count)  [unit√©s libres, ex: secondes]
//!   - Timer      (helper : start/stop -> observe dans <name>_seconds)
//!
//! API rapide
//!   metrics::counter_inc("http_requests_total", 1, labels)
//!   metrics::gauge_set("workers", 4, labels)
//!   metrics::hist_observe("http_request_duration_seconds", 0.123, labels)
//!   let t = metrics::timer_start("job_runtime", labels); /* ... */ metrics::timer_stop(t)
//!   let text = metrics::prometheus_export()
//!
//! Convention labels : Map[str,str] (ou [] pour aucun). Order-insensitive -> signature stable.
//!
//! Licence : MIT

use string
use mathx

// -------------------- Erreurs & types de base --------------------

pub enum MetricError {
  TypeMismatch(str),   // nom existe mais d‚Äôun autre type
  InvalidName(str),
  InvalidValue(str),
}

pub enum MetricKind { Counter, Gauge, Histogram }

pub struct Counter { value: f64 }
pub struct Gauge   { value: f64 }

pub struct Histogram {
  // Buckets tri√©s par upper bound inclusif (Prometheus style).
  bounds: Vec[f64],
  bucket_counts: Vec[u64], // cumulatifs
  sum: f64,
  count: u64,
}

// Timer l√©ger ‚Äî enregistre dans <name>_seconds (histogram) √† l‚Äôarr√™t.
pub struct Timer {
  name: String,
  labels: Map[str,str],
  start_ns: u64,
}

// M√©tadonn√©es d‚Äôun metric
pub struct Meta {
  name: String,
  kind: MetricKind,
  help: String,
}

// Entr√©e de registre
pub enum Cell {
  C(Counter),
  G(Gauge),
  H(Histogram),
}

pub struct Entry {
  meta: Meta,
  cell: Cell,
}

// Registre global : (key -> Entry)
// key = name + '|' + label_signature(labels)
pub struct Registry {
  by_key: Map[String, Entry],
}

// -------------------- Singleton registre (non verrouill√© ici) --------------------

let mut __REGISTRY: Option[Registry] = None

inline do registry_mut() -> &mut Registry {
  if __REGISTRY.is_none() {
    __REGISTRY = Some(Registry{ by_key: Map::new() })
  }
  __REGISTRY.as_mut().unwrap()
}

// -------------------- Helpers labels & cl√©s --------------------

inline do sanitize_name(name: str) -> Result[String, MetricError] {
  if name.len() == 0 { return Err(MetricError::InvalidName("empty")) }
  // Prom-style: [a-zA-Z_:][a-zA-Z0-9_:]*
  let mut ok = true
  let mut out = String::with_capacity(name.len())
  let mut i = 0
  for ch in name.chars() {
    let c = ch as u32
    if i == 0 {
      ok = (ch == '_' || ch == ':' || (c >= 65 && c <= 90) || (c >= 97 && c <= 122))
    } else {
      ok = (ch == '_' || ch == ':' || (c >= 48 && c <= 57) || (c >= 65 && c <= 90) || (c >= 97 && c <= 122))
    }
    out.push(if ok { ch } else { '_' })
    i += 1
  }
  Ok(out)
}

// Convertit labels -> signature tri√©e "k=v,k2=v2" (√©chappes simples, stable)
inline do label_signature(labels: Map[str,str]) -> String {
  if labels.len() == 0 { return String::from("") }
  let mut keys = Vec::with_capacity(labels.len())
  for (k, _) in labels { keys.push(String::from(k)) }
  keys.sort()
  let mut parts = Vec::with_capacity(keys.len())
  for k in keys {
    let v = labels.get(&k).unwrap()
    parts.push(k + "=" + v)
  }
  string::join(parts, ",")
}

inline do make_key(name: str, labels: Map[str,str]) -> String {
  let sig = label_signature(labels)
  if sig.len() == 0 { String::from(name) } else { String::from(name) + "|" + sig }
}

// -------------------- Construction / enregistrement --------------------

inline do ensure_counter(name: str, help: str, labels: Map[str,str]) -> Result[&mut Counter, MetricError] {
  let n = sanitize_name(name)?
  let key = make_key(n, labels)
  let reg = registry_mut()
  if !reg.by_key.contains_key(&key) {
    reg.by_key.insert(key.clone(), Entry{
      meta: Meta{ name: n, kind: MetricKind::Counter, help: String::from(help) },
      cell: Cell::C(Counter{ value: 0.0 })
    })
  }
  let e = reg.by_key.get_mut(&key).unwrap()
  match e.cell {
    Cell::C(ref mut c) => Ok(c),
    _ => Err(MetricError::TypeMismatch(String::from(name))),
  }
}

inline do ensure_gauge(name: str, help: str, labels: Map[str,str]) -> Result[&mut Gauge, MetricError] {
  let n = sanitize_name(name)?
  let key = make_key(n, labels)
  let reg = registry_mut()
  if !reg.by_key.contains_key(&key) {
    reg.by_key.insert(key.clone(), Entry{
      meta: Meta{ name: n, kind: MetricKind::Gauge, help: String::from(help) },
      cell: Cell::G(Gauge{ value: 0.0 })
    })
  }
  let e = reg.by_key.get_mut(&key).unwrap()
  match e.cell {
    Cell::G(ref mut g) => Ok(g),
    _ => Err(MetricError::TypeMismatch(String::from(name))),
  }
}

inline do default_buckets() -> Vec[f64] {
  // buckets ‚Äúlatence‚Äù en secondes : ~ prometheus defaults √©tendus
  vec![0.001, 0.005, 0.01, 0.025, 0.05, 0.075,
       0.1, 0.25, 0.5, 0.75,
       1.0, 2.5, 5.0, 7.5,
       10.0]
}

inline do ensure_histogram(name: str, help: str, labels: Map[str,str], bounds_opt: Option[Vec[f64]]) -> Result[&mut Histogram, MetricError] {
  let n = sanitize_name(name)?
  let key = make_key(n, labels)
  let reg = registry_mut()
  if !reg.by_key.contains_key(&key) {
    let mut b = match bounds_opt { Some(v) => v, None => default_buckets() }
    b.sort()
    let mut counts = Vec::with_capacity(b.len())
    for _ in b { counts.push(0) }
    reg.by_key.insert(key.clone(), Entry{
      meta: Meta{ name: n, kind: MetricKind::Histogram, help: String::from(help) },
      cell: Cell::H(Histogram{ bounds: b, bucket_counts: counts, sum: 0.0, count: 0 })
    })
  }
  let e = reg.by_key.get_mut(&key).unwrap()
  match e.cell {
    Cell::H(ref mut h) => Ok(h),
    _ => Err(MetricError::TypeMismatch(String::from(name))),
  }
}

// -------------------- API publique ‚Äî Counter --------------------

pub do counter_add(name: str, by: f64, labels: Map[str,str]) -> Result[Unit, MetricError] {
  if by.is_nan() || by < 0.0 { return Err(MetricError::InvalidValue("counter must be >= 0")) }
  let c = ensure_counter(name, "", labels)?
  c.value += by
  Ok(())
}

pub inline do counter_inc(name: str, labels: Map[str,str]) -> Result[Unit, MetricError] {
  counter_add(name, 1.0, labels)
}

pub do counter_get(name: str, labels: Map[str,str]) -> Option[f64] {
  let key = make_key(name, labels)
  let reg = registry_mut()
  match reg.by_key.get(&key) {
    Some(e) => match e.cell {
      Cell::C(ref c) => Some(c.value),
      _ => None
    },
    None => None
  }
}

// -------------------- API publique ‚Äî Gauge --------------------

pub do gauge_set(name: str, val: f64, labels: Map[str,str]) -> Result[Unit, MetricError] {
  if val.is_nan() { return Err(MetricError::InvalidValue("NaN")) }
  let g = ensure_gauge(name, "", labels)?
  g.value = val
  Ok(())
}

pub do gauge_add(name: str, by: f64, labels: Map[str,str]) -> Result[Unit, MetricError] {
  if by.is_nan() { return Err(MetricError::InvalidValue("NaN")) }
  let g = ensure_gauge(name, "", labels)?
  g.value += by
  Ok(())
}

pub inline do gauge_inc(name: str, labels: Map[str,str]) -> Result[Unit, MetricError] {
  gauge_add(name, 1.0, labels)
}
pub inline do gauge_dec(name: str, labels: Map[str,str]) -> Result[Unit, MetricError] {
  gauge_add(name, -1.0, labels)
}

pub do gauge_get(name: str, labels: Map[str,str]) -> Option[f64] {
  let key = make_key(name, labels)
  let reg = registry_mut()
  match reg.by_key.get(&key) {
    Some(e) => match e.cell {
      Cell::G(ref g) => Some(g.value),
      _ => None
    },
    None => None
  }
}

// -------------------- API publique ‚Äî Histogram --------------------

pub do hist_observe_with(name: str, val: f64, labels: Map[str,str], bounds: Vec[f64]) -> Result[Unit, MetricError] {
  if val.is_nan() { return Err(MetricError::InvalidValue("NaN")) }
  let h = ensure_histogram(name, "", labels, Some(bounds))?
  hist_observe_impl(h, val)
  Ok(())
}

pub do hist_observe(name: str, val: f64, labels: Map[str,str]) -> Result[Unit, MetricError] {
  if val.is_nan() { return Err(MetricError::InvalidValue("NaN")) }
  let h = ensure_histogram(name, "", labels, None)?
  hist_observe_impl(h, val)
  Ok(())
}

inline do hist_observe_impl(h &mut Histogram, val: f64) {
  // incr√©ment bucket cumulatif
  let mut i: usize = 0
  while i < h.bounds.len() {
    if val <= h.bounds[i] { h.bucket_counts[i] += 1 }
    i += 1
  }
  h.sum += val
  h.count += 1
}

pub do hist_snapshot(name: str, labels: Map[str,str]) -> Option[(Vec[f64], Vec[u64], f64, u64)] {
  let key = make_key(name, labels)
  let reg = registry_mut()
  match reg.by_key.get(&key) {
    Some(e) => match e.cell {
      Cell::H(ref h) => {
        // copies l√©g√®res pour exposition
        let mut b = Vec::with_capacity(h.bounds.len())
        for x in h.bounds { b.push(x) }
        let mut c = Vec::with_capacity(h.bucket_counts.len())
        for x in h.bucket_counts { c.push(x) }
        Some((b, c, h.sum, h.count))
      }
      _ => None
    },
    None => None
  }
}

// -------------------- Timers --------------------

extern(c) do __vitte_now_ns() -> u64

pub do timer_start(name: str, labels: Map[str,str]) -> Timer {
  Timer{ name: String::from(name), labels, start_ns: __vitte_now_ns() }
}

pub do timer_stop(t: Timer) -> Result[Unit, MetricError] {
  let elapsed = (__vitte_now_ns() - t.start_ns) as f64 / 1_000_000_000.0
  // Observe dans "<name>_seconds"
  let full = String::from(t.name) + "_seconds"
  hist_observe(full, elapsed, t.labels)
}

// -------------------- Export Prometheus (texte) --------------------
// Exemple :
//   # HELP http_requests_total Total HTTP requests
//   # TYPE http_requests_total counter
//   http_requests_total{method="GET",code="200"} 1027
//   http_request_duration_seconds_bucket{le="0.1"} 12
//   http_request_duration_seconds_bucket{le="+Inf"} 34
//   http_request_duration_seconds_sum 12.345
//   http_request_duration_seconds_count 34

inline do esc_label_val(v: str) -> String {
  // √âchappes : backslash, double-quote, newline
  let mut s = String::with_capacity(v.len() + 4)
  for ch in v.chars() {
    match ch {
      '\\' => s.push_str("\\\\"),
      '"'  => s.push_str("\\\""),
      '\n' => s.push_str("\\n"),
      _    => s.push(ch),
    }
  }
  s
}

inline do labels_to_str(labels: Map[str,str]) -> String {
  if labels.len() == 0 { return String::from("") }
  let mut keys = Vec::with_capacity(labels.len())
  for (k, _) in labels { keys.push(String::from(k)) }
  keys.sort()
  let mut parts = Vec::with_capacity(keys.len())
  for k in keys {
    let v = labels.get(&k).unwrap()
    parts.push(k + "=\"" + esc_label_val(v) + "\"")
  }
  "{" + string::join(parts, ",") + "}"
}

pub do prometheus_export() -> String {
  let reg = registry_mut()
  let mut out = String::with_capacity(4096)

  // It√®re stablement par nom (puis par cl√©) pour une sortie d√©terministe
  let mut names = Vec::new()
  for (_, e) in reg.by_key {
    if !names.contains(&e.meta.name) { names.push(String::from(e.meta.name)) }
  }
  names.sort()

  for n in names {
    // HELP / TYPE ‚Äî imprim√©s une fois par nom (par convention : premier entry)
    // Cherche le premier entry de ce nom
    let mut kind: MetricKind = MetricKind::Counter
    let mut help = ""
    for (_, e) in reg.by_key {
      if e.meta.name == n {
        kind = e.meta.kind; help = e.meta.help; break
      }
    }
    if help.len() > 0 { out.push_str("# HELP " + n + " " + help + "\n") }
    let typ = match kind { MetricKind::Counter => "counter", MetricKind::Gauge => "gauge", MetricKind::Histogram => "histogram" }
    out.push_str("# TYPE " + n + " " + typ + "\n")

    // Imprimer toutes les s√©ries pour ce nom
    // Trie par labels (cl√© compl√®te) pour stabilit√©
    let mut pairs = Vec::new()
    for (k, e) in reg.by_key {
      if e.meta.name == n { pairs.push((k, e)) }
    }
    pairs.sort_by(|a, b| a.0.cmp(&b.0))

    for (k, e) in pairs {
      // Reconstituer les labels depuis la cl√© (k = name|k=v,...)
      let mut labels: Map[str,str] = Map::new()
      let idx = k.find("|")
      if idx.is_some() {
        let sig = k[(idx.unwrap()+1)..]
        if sig.len() > 0 {
          for part in string::split(sig, ",") {
            let eq = part.find("=")
            if eq.is_some() {
              let kk = part[0..eq.unwrap()]
              let vv = part[(eq.unwrap()+1)..]
              labels.insert(String::from(kk), String::from(vv))
            }
          }
        }
      }

      match e.cell {
        Cell::C(ref c) => {
          out.push_str(n + labels_to_str(labels) + " " + to_string(c.value) + "\n")
        }
        Cell::G(ref g) => {
          out.push_str(n + labels_to_str(labels) + " " + to_string(g.value) + "\n")
        }
        Cell::H(ref h) => {
          // Buckets (cumulatifs)
          let mut i: usize = 0
          while i < h.bounds.len() {
            let mut lbs = labels.clone()
            lbs.insert(String::from("le"), to_string(h.bounds[i]))
            out.push_str(n + "_bucket" + labels_to_str(lbs) + " " + to_string(h.bucket_counts[i]) + "\n")
            i += 1
          }
          // +Inf bucket = count total
          let mut lbs_inf = labels.clone()
          lbs_inf.insert(String::from("le"), "+Inf")
          out.push_str(n + "_bucket" + labels_to_str(lbs_inf) + " " + to_string(h.count) + "\n")

          out.push_str(n + "_sum" + labels_to_str(labels) + " " + to_string(h.sum) + "\n")
          out.push_str(n + "_count" + labels_to_str(labels) + " " + to_string(h.count) + "\n")
        }
      }
    }
  }

  out
}

// -------------------- Maintenance / reset --------------------

pub do reset_metric(name: str) {
  // Supprime toutes les s√©ries partageant ce nom
  let reg = registry_mut()
  // Collect keys to delete (can't mutate while iterating)
  let mut ks = Vec::new()
  for (k, e) in reg.by_key {
    if e.meta.name == name { ks.push(String::from(k)) }
  }
  for k in ks { reg.by_key.remove(&k) }
}

pub do clear_all() {
  let reg = registry_mut()
  reg.by_key.clear()
}

// -------------------- Tests rapides --------------------
// @test
do _metrics_smoke() {
  clear_all()
  counter_inc("hits_total", map!{})?
  counter_add("hits_total", 3, map!{})?
  assert(counter_get("hits_total", map!{}).unwrap() == 4.0, "counter")

  gauge_set("workers", 2, map!{})?
  gauge_inc("workers", map!{})?
  assert(gauge_get("workers", map!{}).unwrap() == 3.0, "gauge")

  hist_observe("latency_seconds", 0.12, map!{})?
  hist_observe("latency_seconds", 0.02, map!{})?
  let snap = hist_snapshot("latency_seconds", map!{}).unwrap()
  let (_, _, sum, count) = snap
  assert(count == 2, "hist count")
  assert(mathx::almost_eq_f64(sum, 0.14, 1e-12), "hist sum")

  let t = timer_start("job", map!{"kind" => "reindex"})
  // ... simulate ...
  timer_stop(t)?
  let exp = prometheus_export()
  assert(exp.contains("# TYPE job_seconds histogram"), "export hdr")
}
