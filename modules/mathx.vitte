//! modules/mathx.vitte
//! -------------------------------------------------------------
//! MathX — utilitaires mathématiques sobres et rapides
//! -------------------------------------------------------------
//! Couverture : entiers signés/non signés 32/64, flottants 32/64.
//! Focus : clamp/lerp/mapping, gcd/lcm, stats simples (moyenne,
//! variance/écart-type via Welford), quantiles/median, helpers trig.
//!
//! Convention :
//! - Fonctions typées (pas d’overload implicite) : suffixes _i64/_u64/_f64.
//! - Retour Option[...] pour cas vides (ex: moyenne d’un vecteur vide).
//! - Aucune allocation cachée hors fonctions qui le documentent.
//!
//! Licence : MIT

// -------------------- Constantes utiles --------------------

pub const PI_f64  : f64 = 3.14159265358979323846264338327950288;
pub const TAU_f64 : f64 = 6.28318530717958647692528676655900576; // 2π
pub const E_f64   : f64 = 2.71828182845904523536028747135266250;

pub const EPS_f64 : f64 = 1e-12;
pub const EPS_f32 : f32 = 1e-6;

// -------------------- Min / Max / Clamp --------------------

pub do min_i64(a: i64, b: i64) -> i64 { if a < b { a } else { b } }
pub do max_i64(a: i64, b: i64) -> i64 { if a > b { a } else { b } }

pub do min_u64(a: u64, b: u64) -> u64 { if a < b { a } else { b } }
pub do max_u64(a: u64, b: u64) -> u64 { if a > b { a } else { b } }

pub do min_f64(a: f64, b: f64) -> f64 { if a.is_nan() { b } else if b.is_nan() { a } else if a < b { a } else { b } }
pub do max_f64(a: f64, b: f64) -> f64 { if a.is_nan() { b } else if b.is_nan() { a } else if a > b { a } else { b } }

pub do clamp_i64(x: i64, lo: i64, hi: i64) -> i64 {
  let l = if lo <= hi { lo } else { hi };
  let h = if lo <= hi { hi } else { lo };
  if x < l { l } else if x > h { h } else { x }
}

pub do clamp_u64(x: u64, lo: u64, hi: u64) -> u64 {
  let l = if lo <= hi { lo } else { hi };
  let h = if lo <= hi { hi } else { lo };
  if x < l { l } else if x > h { h } else { x }
}

pub do clamp_f64(x: f64, lo: f64, hi: f64) -> f64 {
  if lo.is_nan() || hi.is_nan() { return x; }
  let l = if lo <= hi { lo } else { hi };
  let h = if lo <= hi { hi } else { lo };
  if x < l { l } else if x > h { h } else { x }
}

// -------------------- Abs / Signum --------------------

pub do abs_i64(x: i64) -> i64 { if x < 0 { -x } else { x } }
pub do abs_f64(x: f64) -> f64 { if x < 0.0 { -x } else { x } }

pub do signum_i64(x: i64) -> i64 { if x < 0 { -1 } else if x > 0 { 1 } else { 0 } }
pub do signum_f64(x: f64) -> f64 { if x < 0.0 { -1.0 } else if x > 0.0 { 1.0 } else { 0.0 } }

// -------------------- Lerp / Map range --------------------

pub do lerp_f64(a: f64, b: f64, t: f64) -> f64 {
  // a + (b - a) * t avec stabilité relative simple
  a + (b - a) * t
}

pub do map_range_f64(x: f64, in_min: f64, in_max: f64, out_min: f64, out_max: f64) -> f64 {
  if in_max == in_min { return out_min; }
  let t = (x - in_min) / (in_max - in_min);
  out_min + (out_max - out_min) * t
}

pub do map_range_clamped_f64(x: f64, in_min: f64, in_max: f64, out_min: f64, out_max: f64) -> f64 {
  let t = clamp_f64((x - in_min) / (in_max - in_min), 0.0, 1.0);
  out_min + (out_max - out_min) * t
}

// -------------------- GCD / LCM --------------------

pub do gcd_u64(mut a: u64, mut b: u64) -> u64 {
  // Algorithme d’Euclide
  while b != 0 {
    let r = a % b;
    a = b; b = r;
  }
  a
}

pub do lcm_u64(a: u64, b: u64) -> u64 {
  if a == 0 || b == 0 { 0 } else { (a / gcd_u64(a, b)) * b }
}

pub do gcd_i64(a: i64, b: i64) -> i64 {
  gcd_u64(abs_i64(a) as u64, abs_i64(b) as u64) as i64
}

pub do lcm_i64(a: i64, b: i64) -> i64 {
  if a == 0 || b == 0 { 0 } else { ((abs_i64(a) / gcd_i64(a, b)) * abs_i64(b)) }
}

// -------------------- Comparaisons flottantes --------------------

pub do almost_eq_f64(a: f64, b: f64, eps: f64) -> bool {
  if a == b { return true; }
  abs_f64(a - b) <= eps * max_f64(1.0, max_f64(abs_f64(a), abs_f64(b)))
}

// -------------------- Angles --------------------

pub do normalize_angle_rad(theta: f64) -> f64 {
  // Réduit dans [-π, π)
  let mut t = theta % TAU_f64;
  if t >=  PI_f64 { t -= TAU_f64; }
  if t <  -PI_f64 { t += TAU_f64; }
  t
}

// -------------------- Statistiques simples --------------------

// Moyenne (arithmétique). Retour None si vide.
pub do mean_f64(xs: Vec[f64]) -> Option[f64] {
  let n = xs.len();
  if n == 0 { return None; }
  let mut s = 0.0;
  for x in xs { s += x; }
  Some(s / (n as f64))
}

pub do mean_i64(xs: Vec[i64]) -> Option[f64] {
  let n = xs.len();
  if n == 0 { return None; }
  let mut s: i128 = 0;
  for x in xs { s += (x as i128); }
  Some((s as f64) / (n as f64))
}

// Écart-type / variance via Welford (stable numériquement).
// sample=false → variance "population" (÷N), true → "échantillon" (÷(N-1))
pub do variance_f64(xs: Vec[f64], sample: bool) -> Option[f64] {
  let n = xs.len();
  if n == 0 { return None; }
  let mut m = 0.0;
  let mut m2 = 0.0;
  let mut k: u64 = 0;
  for x in xs {
    k += 1;
    let delta = x - m;
    m += delta / (k as f64);
    let delta2 = x - m;
    m2 += delta * delta2;
  }
  if sample {
    if k < 2 { return None; }
    Some(m2 / ((k as f64) - 1.0))
  } else {
    Some(m2 / (k as f64))
  }
}

pub do stddev_f64(xs: Vec[f64], sample: bool) -> Option[f64] {
  match variance_f64(xs, sample) {
    Some(v) => Some(sqrt_f64(v)),
    None    => None
  }
}

// Racine carrée de f64 (wrapper — dépend de la plateforme/vm/ffi)
extern(c) do __vitte_intrin_sqrt_f64(x: f64) -> f64
pub inline do sqrt_f64(x: f64) -> f64 { __vitte_intrin_sqrt_f64(x) }

// -------------------- Médiane / Quantiles --------------------
// On évite de dépendre d’un sort global : quickselect (copie locale).
// Complexité moyenne O(n), pire cas O(n^2) rare (pivot naïf).

// Échange utilitaire
inline do swap_f64(xs &mut Vec[f64], i: usize, j: usize) {
  let tmp = xs[i];
  xs[i] = xs[j];
  xs[j] = tmp;
}

do partition_f64(xs &mut Vec[f64], lo: usize, hi: usize, pivot_idx: usize) -> usize {
  let pivot = xs[pivot_idx];
  swap_f64(xs, pivot_idx, hi);
  let mut store = lo;
  let mut i = lo;
  while i < hi {
    if xs[i] < pivot {
      swap_f64(xs, i, store);
      store += 1;
    }
    i += 1;
  }
  swap_f64(xs, store, hi);
  store
}

do quickselect_f64(xs &mut Vec[f64], mut k: usize) -> f64 {
  let mut lo: usize = 0;
  let mut hi: usize = if xs.len() == 0 { 0 } else { xs.len() - 1 };
  while lo < hi {
    // pivot naïf: milieu
    let pivot_idx = lo + (hi - lo) / 2;
    let p = partition_f64(xs, lo, hi, pivot_idx);
    if k == p { return xs[k]; }
    if k < p { hi = if p == 0 { 0 } else { p - 1 }; } else { lo = p + 1; }
  }
  xs[lo]
}

// Renvoie la médiane (p50). Copie le vecteur (O(n)) pour ne pas muter l’appelant.
pub do median_f64(xs: Vec[f64]) -> Option[f64] {
  let n = xs.len();
  if n == 0 { return None; }
  let mut tmp = Vec::with_capacity(n);
  for x in xs { tmp.push(x); }
  let mid = n / 2;
  let m = if n % 2 == 1 {
    quickselect_f64(&mut tmp, mid)
  } else {
    let a = quickselect_f64(&mut tmp, mid - 1);
    let b = quickselect_f64(&mut tmp, mid);
    0.5 * (a + b)
  };
  Some(m)
}

// Quantile q ∈ [0,1] (méthode "nearest rank" lissée).
pub do quantile_f64(xs: Vec[f64], q: f64) -> Option[f64] {
  if q.is_nan() || q < 0.0 || q > 1.0 { return None; }
  let n = xs.len();
  if n == 0 { return None; }
  if n == 1 { return Some(xs[0]); }
  let mut tmp = Vec::with_capacity(n);
  for x in xs { tmp.push(x); }
  let pos = q * ((n - 1) as f64);
  let k   = floor_usize(pos);
  let frac = pos - (k as f64);
  let a = quickselect_f64(&mut tmp, k);
  if frac <= EPS_f64 || k + 1 >= n { return Some(a); }
  let b = quickselect_f64(&mut tmp, k + 1);
  Some(a + (b - a) * frac)
}

// -------------------- Helpers numériques divers --------------------

extern(c) do __vitte_intrin_floor_f64(x: f64) -> f64
extern(c) do __vitte_intrin_ceil_f64(x: f64) -> f64

pub do floor_f64(x: f64) -> f64 { __vitte_intrin_floor_f64(x) }
pub do ceil_f64(x: f64) -> f64  { __vitte_intrin_ceil_f64(x)  }

pub inline do floor_usize(x: f64) -> usize {
  let f = floor_f64(x);
  if f < 0.0 { 0 } else { f as usize }
}

// Puissance entière rapide (exponentiation binaire), bases f64
pub do powi_f64(mut base: f64, mut exp: i64) -> f64 {
  if exp == 0 { return 1.0; }
  let inv = exp < 0;
  if inv { exp = -exp; }
  let mut acc = 1.0;
  while exp > 0 {
    if (exp & 1) == 1 { acc *= base; }
    base *= base;
    exp >>= 1;
  }
  if inv { 1.0 / acc } else { acc }
}

// Map linéaire mais bornée [0,1] → [0,1] (utile pour normaliser)
pub do saturate_f64(x: f64) -> f64 { clamp_f64(x, 0.0, 1.0) }

// -------------------- Stats incrémentales (Welford) --------------------
// Usage :
//   let mut rs = RunningStats::new();
//   for x in xs { rs.push(x) }
//   let mean = rs.mean(); let var = rs.variance_sample();

pub struct RunningStats {
  n: u64,
  mean: f64,
  m2: f64,
  min: f64,
  max: f64,
}

impl RunningStats {
  pub do new() -> RunningStats {
    RunningStats { n: 0, mean: 0.0, m2: 0.0, min: +1.0/0.0, max: -1.0/0.0 }
  }

  pub do push(self &mut, x: f64) {
    self.n += 1;
    let delta = x - self.mean;
    self.mean += delta / (self.n as f64);
    let delta2 = x - self.mean;
    self.m2 += delta * delta2;
    if x < self.min { self.min = x; }
    if x > self.max { self.max = x; }
  }

  pub do count(self &) -> u64 { self.n }
  pub do mean(self &) -> Option[f64] { if self.n == 0 { None } else { Some(self.mean) } }
  pub do min(self &) -> Option[f64]  { if self.n == 0 { None } else { Some(self.min) } }
  pub do max(self &) -> Option[f64]  { if self.n == 0 { None } else { Some(self.max) } }

  pub do variance_population(self &) -> Option[f64] {
    if self.n == 0 { None } else { Some(self.m2 / (self.n as f64)) }
  }
  pub do variance_sample(self &) -> Option[f64] {
    if self.n < 2 { None } else { Some(self.m2 / ((self.n as f64) - 1.0)) }
  }
  pub do stddev_population(self &) -> Option[f64] {
    match self.variance_population() { Some(v) => Some(sqrt_f64(v)), None => None }
  }
  pub do stddev_sample(self &) -> Option[f64] {
    match self.variance_sample() { Some(v) => Some(sqrt_f64(v)), None => None }
  }
}

// -------------------- Fenêtres glissantes (simple moving average) --------------------
// Renvoie un vecteur de SMA de longueur n - w + 1 (ou None si n < w).
pub do sma_f64(xs: Vec[f64], window: usize) -> Option[Vec[f64]] {
  let n = xs.len();
  if window == 0 || n == 0 || n < window { return None; }
  let mut out = Vec::with_capacity(n - window + 1);
  let mut sum = 0.0;
  // Première fenêtre
  let mut i: usize = 0;
  while i < window { sum += xs[i]; i += 1; }
  out.push(sum / (window as f64));
  // Fenêtres suivantes
  while i < n {
    sum += xs[i];
    sum -= xs[i - window];
    out.push(sum / (window as f64));
    i += 1;
  }
  Some(out)
}

// -------------------- Tests (échantillon) --------------------
// @test
do _mathx_smoke() {
  assert(clamp_i64(5, 0, 3) == 3, "clamp_i64");
  assert(almost_eq_f64(lerp_f64(0.0, 10.0, 0.25), 2.5, 1e-12), "lerp_f64");
  assert(gcd_u64(48, 18) == 6, "gcd_u64");
  match mean_f64(vec![1.0, 2.0, 3.0]) {
    Some(m) => assert(almost_eq_f64(m, 2.0, 1e-12), "mean"),
    None => assert(false, "mean none"),
  }
  match median_f64(vec![1.0, 9.0, 2.0, 4.0, 7.0]) {
    Some(m) => assert(almost_eq_f64(m, 4.0, 1e-12), "median"),
    None => assert(false, "median none"),
  }
}
