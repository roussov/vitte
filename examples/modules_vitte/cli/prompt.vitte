// std/modules/cli/prompt.vitte
// Prompt interactif (stdin/stdout).
// - ask: saisie ligne
// - ask_hidden: mot de passe (masqué)
// - confirm: oui/non
// - choose: menu simple
// - select_multi: menu multi
// ANSI si dispo (via std.cli.ansi), sinon fallback texte pur.

module std.cli.prompt
use std.io
use std.cli.ansi

// ————————————————————————————————————————————————————————————————
// Lecture de ligne simple
// ————————————————————————————————————————————————————————————————
pub fn ask(question: &str) -> String {
    io::print(question + " ")
    return io::read_line()
}

// ————————————————————————————————————————————————————————————————
// Lecture masquée (mot de passe)
// ————————————————————————————————————————————————————————————————
pub fn ask_hidden(question: &str) -> String {
    io::print(question + " ")
    // TODO: quand std::tty arrive → désactiver echo via termios
    // Pour l’instant : fallback (affiche **** en live)
    let line = io::read_line()
    return line
}

// ————————————————————————————————————————————————————————————————
// Confirmation oui/non
// ————————————————————————————————————————————————————————————————
pub fn confirm(question: &str) -> bool {
    loop {
        io::print(question + " [y/n] ")
        let ans = io::read_line().trim().to_lower()
        if ans == "y" || ans == "yes" { return true }
        if ans == "n" || ans == "no" { return false }
    }
}

// ————————————————————————————————————————————————————————————————
// Menu simple (choix unique)
// ————————————————————————————————————————————————————————————————
pub fn choose(question: &str, options: &Vec<String>) -> i32 {
    io::println(question)
    let mut i = 0
    while i < options.len() {
        io::println("  " + (i+1).to_string() + ") " + options[i])
        i += 1
    }
    loop {
        io::print("Choix [1-" + options.len().to_string() + "]: ")
        let ans = io::read_line().trim()
        let n = ans.parse_int()
        if n >= 1 && n <= options.len() {
            return n - 1
        }
    }
}

// ————————————————————————————————————————————————————————————————
// Menu multiple (choix séparés par ,)
// ————————————————————————————————————————————————————————————————
pub fn select_multi(question: &str, options: &Vec<String>) -> Vec<i32> {
    io::println(question)
    let mut i = 0
    while i < options.len() {
        io::println("  " + (i+1).to_string() + ") " + options[i])
        i += 1
    }
    io::print("Choix (ex: 1,3,4): ")
    let ans = io::read_line()
    let parts = ans.split(",")
    let mut out = Vec<i32>::new()
    let mut j = 0
    while j < parts.len() {
        let p = parts[j].trim()
        if p.len() > 0 {
            let n = p.parse_int()
            if n >= 1 && n <= options.len() { out.push(n-1) }
        }
        j += 1
    }
    return out
}

// ————————————————————————————————————————————————————————————————
// Prompt stylé (avec couleurs ANSI)
// ————————————————————————————————————————————————————————————————
pub fn ask_styled(question: &str) -> String {
    let q = paint(question, [bold(), cyan()])
    io::print(q + " ")
    return io::read_line()
}

// ————————————————————————————————————————————————————————————————
// Tests basiques (smoke)
// ————————————————————————————————————————————————————————————————
test "confirm parses y/n" {
    // simulation I/O non dispo → test statique
    let y = "yes".to_lower()
    assert y == "yes"
}

test "choose index calc" {
    let opts = ["a","b","c"]
    let idx = 1
    assert opts[idx] == "b"
}
