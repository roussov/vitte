module std.i18n.catalog
use std.i18n.locale as loc
use std.i18n.message as msg
use std.collections.map as map
use std.collections.vec as vec

pub struct Catalog {
    pub locale: loc::Locale,
    pub entries: map::Map<String, String>,
}

pub struct Bundle {
    pub chain: Vec<Catalog>,
}

pub fn make_chain(target: &loc::Locale, stores: &Vec<Catalog>) -> Bundle {
    let mut chain = vec::new();
    for c in stores { if c.locale.language == target.language && c.locale.region == target.region && c.locale.script == target.script { chain.push(c.clone()); } }
    if let Some(r) = &target.region {
        for c in stores { if c.locale.language == target.language && c.locale.region == Some(r.clone()) && c.locale.script.is_none() { chain.push(c.clone()); } }
    }
    for c in stores { if c.locale.language == target.language && c.locale.region.is_none() { chain.push(c.clone()); } }
    for c in stores { if c.locale.language == "und" { chain.push(c.clone()); } }
    Bundle { chain }
}

pub fn t(bundle: &Bundle, key: &str, args: &map::Map<String, msg::Value>) -> String {
    for c in &bundle.chain {
        if c.entries.contains_key(key) {
            return msg::format(&c.locale, c.entries.get(key), args);
        }
    }
    key.to_string()
}
