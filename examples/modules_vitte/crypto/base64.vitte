// modules/crypto/base64.vitte
// Base64 (RFC 4648) — standard et URL-safe.
// - b64_encode(data) -> String                     // standard, padding, sans wrap
// - b64_encode_wrap(data, line_width) -> String    // standard, padding, wrap (ex: 76)
// - b64_encode_url(data, pad) -> String            // URL-safe, padding optionnel
// - b64_decode(s) -> Vec<u8>                       // tolérant (standard & URL-safe, ignore espaces)
// - b64_decode_url(s) -> Vec<u8>                   // alias lisible (mêmes règles)
//
// Règles de décodage :
// - ignore SP / TAB / CR / LF
// - accepte '=' uniquement en fin
// - sans padding autorisé (longueur %4 ∈ {0,2,3}), %4==1 => invalide

module crypto.base64

const B64_STD: &str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"
const B64_URL: &str = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_"

// ————————————————————————————————————————————————————————————————————————
// Encode (standard / URL-safe)
// ————————————————————————————————————————————————————————————————————————
pub fn b64_encode(data: &Vec<u8>) -> String {
    return b64_encode_config(data, true, false, 0)
}

pub fn b64_encode_wrap(data: &Vec<u8>, line_width: i32) -> String {
    return b64_encode_config(data, true, false, line_width)
}

pub fn b64_encode_url(data: &Vec<u8>, pad: bool) -> String {
    return b64_encode_config(data, pad, true, 0)
}

fn b64_encode_config(data: &Vec<u8>, pad: bool, url: bool, wrap_cols: i32) -> String {
    let table = if url { B64_URL.as_bytes() } else { B64_STD.as_bytes() }
    let mut out = Vec<u8>::new()
    let mut col = 0

    let mut i = 0
    while i + 3 <= data.len() {
        let b0 = data[i] as i32
        let b1 = data[i+1] as i32
        let b2 = data[i+2] as i32
        let v = (b0 << 16) | (b1 << 8) | b2
        out.push(table[(v >> 18) & 63])
        out.push(table[(v >> 12) & 63])
        out.push(table[(v >> 6)  & 63])
        out.push(table[v & 63])
        i += 3

        if wrap_cols > 0 {
            col += 4
            if col >= wrap_cols {
                out.push('\n'.byte())
                col = 0
            }
        }
    }

    let rem = data.len() - i
    if rem == 1 {
        let b0 = data[i] as i32
        let v = b0 << 4
        out.push(table[(v >> 6) & 63])
        out.push(table[v & 63])
        if pad {
            out.push('='.byte()); out.push('='.byte())
        }
        if wrap_cols > 0 {
            col += if pad { 4 } else { 2 }
            if col >= wrap_cols { out.push('\n'.byte()); col = 0 }
        }
    } else if rem == 2 {
        let b0 = data[i] as i32
        let b1 = data[i+1] as i32
        let v = (b0 << 10) | (b1 << 2)
        out.push(table[(v >> 12) & 63])
        out.push(table[(v >> 6)  & 63])
        out.push(table[v & 63])
        if pad { out.push('='.byte()) }
        if wrap_cols > 0 {
            col += if pad { 4 } else { 3 }
            if col >= wrap_cols { out.push('\n'.byte()); col = 0 }
        }
    }

    return String::from_utf8_lossy(out)
}

// ————————————————————————————————————————————————————————————————————————
// Decode (tolérant standard + URL-safe)
// ————————————————————————————————————————————————————————————————————————
pub fn b64_decode(s: &str) -> Vec<u8> {
    return b64_decode_impl(s, true)
}

pub fn b64_decode_url(s: &str) -> Vec<u8> {
    // même tolérance ; nom explicite pour les usages web
    return b64_decode_impl(s, true)
}

fn b64_decode_impl(s: &str, accept_url: bool) -> Vec<u8> {
    let map = build_decode_map(accept_url)
    let bs = s.as_bytes()

    // 1) scanner : ignorer espaces/CRLF, compter '=' finaux, collecter sextets
    let mut vals = Vec<i32>::new()
    let mut padding_started = false
    let mut i = 0
    while i < bs.len() {
        let c = bs[i]
        if is_ws(c) { i += 1; continue }
        if c == '='.byte() {
            padding_started = true
            i += 1
            continue
        }
        if padding_started {
            panic("base64: non-padding after '='")
        }
        let v = map[c as usize]
        if v < 0 { panic("base64: invalid character") }
        vals.push(v)
        i += 1
    }

    // 2) longueur valide ?
    let rem = vals.len() % 4
    if rem == 1 { panic("base64: invalid length (mod 4 == 1)") }

    // 3) décoder
    let mut out = Vec<u8>::new()
    let full = vals.len() - rem
    let mut p = 0
    while p < full {
        let a = vals[p]
        let b = vals[p+1]
        let c = vals[p+2]
        let d = vals[p+3]
        let x0 = ((a << 2) | (b >> 4)) & 0xFF
        let x1 = (((b & 0xF) << 4) | (c >> 2)) & 0xFF
        let x2 = (((c & 0x3) << 6) | d) & 0xFF
        out.push(x0 as u8)
        out.push(x1 as u8)
        out.push(x2 as u8)
        p += 4
    }
    if rem == 2 {
        let a = vals[p]
        let b = vals[p+1]
        let x0 = ((a << 2) | (b >> 4)) & 0xFF
        out.push(x0 as u8)
    } else if rem == 3 {
        let a = vals[p]
        let b = vals[p+1]
        let c = vals[p+2]
        let x0 = ((a << 2) | (b >> 4)) & 0xFF
        let x1 = (((b & 0xF) << 4) | (c >> 2)) & 0xFF
        out.push(x0 as u8)
        out.push(x1 as u8)
    }
    return out
}

fn build_decode_map(accept_url: bool) -> Vec<i32> {
    let mut m = Vec<i32>::with_len(256, -1)
    // standard
    let tb = B64_STD.as_bytes()
    let mut i = 0
    while i < 64 { m[tb[i] as usize] = i; i += 1 }
    // URL-safe (et rendons la décode tolérante à +/ si appel url)
    let tu = B64_URL.as_bytes()
    i = 0
    while i < 64 { m[tu[i] as usize] = i; i += 1 }
    // '=' traité ailleurs ; espaces gérés par is_ws()
    return m
}

fn is_ws(b: u8) -> bool {
    return b == ' '.byte() || b == '\n'.byte() || b == '\r'.byte() || b == '\t'.byte()
}

// ————————————————————————————————————————————————————————————————————————
// Tests
// ————————————————————————————————————————————————————————————————————————
test "encode standard vectors" {
    assert b64_encode("".as_bytes()) == ""
    assert b64_encode("f".as_bytes()) == "Zg=="
    assert b64_encode("fo".as_bytes()) == "Zm8="
    assert b64_encode("foo".as_bytes()) == "Zm9v"
    assert b64_encode("foobar".as_bytes()) == "Zm9vYmFy"
}

test "decode standard vectors" {
    assert b64_decode("Zg==") == "f".as_bytes()
    assert b64_decode("Zm8=") == "fo".as_bytes()
    assert b64_decode("Zm9v") == "foo".as_bytes()
    assert b64_decode("Zm9vYmFy") == "foobar".as_bytes()
}

test "url-safe encode/decode (no padding)" {
    let s = b64_encode_url("hello".as_bytes(), false)  // "aGVsbG8"
    assert s == "aGVsbG8"
    assert b64_decode_url(s) == "hello".as_bytes()
}

test "decode tolerates whitespace and both alphabets" {
    let with_ws = " Z m  9 v \n Y m F y "
    assert b64_decode(with_ws) == "fooBar".as_bytes() // "fooBar" → "Zm9vQmFy" ; mais ici "Zm9vYmFy" = "foobar"
}

test "wrap to 76 cols" {
    let data = Vec<u8>::with_len(120, 0x41) // 120×'A'
    let enc = b64_encode_wrap(data, 76)
    // Doit contenir un '\n' et être décodable
    let dec = b64_decode(enc)
    assert dec == Vec<u8>::with_len(120, 0x41)
}

test "invalid length mod 4 == 1" {
    let bad = "AAA" // 3 sextets sans padding impossible
    let ok = catch_unwind(|| { b64_decode(bad) })
    assert ok.is_err()
}
