//! std.core.chrono — API temps et dates
//!
//! Fournit :
//! - Instants (Instant) : horloge monotone pour mesures de durée.
//! - Durées (Duration) : valeurs en ns/µs/ms/s/min/h.
//! - Dates/Heures (DateTime) : basé sur UTC + offset, conversion locale.
//! - Horloges système : maintenant(), unix_time(), monotonic_now().
//! - Formatage/parse rudimentaire (ISO8601).
//!
//! Exemple :
//! ```vitte
//! let start = Instant::now();
//! do_work();
//! let d = start.elapsed();
//! print("Durée: ", d.as_millis(), "ms");
//! ```

module std.core.chrono

use std.core.sys
use std.core.math

// —————————————————————————————————————————————
// Duration
// —————————————————————————————————————————————

public struct Duration {
    nanos: i128
}

impl Duration {
    public fn from_secs(s: i64) -> Duration {
        return Duration { nanos: (s as i128) * 1_000_000_000 };
    }

    public fn from_millis(ms: i64) -> Duration {
        return Duration { nanos: (ms as i128) * 1_000_000 };
    }

    public fn from_micros(us: i64) -> Duration {
        return Duration { nanos: (us as i128) * 1_000 };
    }

    public fn from_nanos(ns: i64) -> Duration {
        return Duration { nanos: ns as i128 };
    }

    public fn as_secs(self: &Duration) -> i64 {
        return (self.nanos / 1_000_000_000) as i64;
    }

    public fn as_millis(self: &Duration) -> i64 {
        return (self.nanos / 1_000_000) as i64;
    }

    public fn as_micros(self: &Duration) -> i64 {
        return (self.nanos / 1_000) as i64;
    }

    public fn as_nanos(self: &Duration) -> i128 {
        return self.nanos;
    }

    // Opérations
    public fn add(self: &Duration, other: &Duration) -> Duration {
        return Duration { nanos: self.nanos + other.nanos };
    }

    public fn sub(self: &Duration, other: &Duration) -> Duration {
        return Duration { nanos: self.nanos - other.nanos };
    }

    public fn neg(self: &Duration) -> Duration {
        return Duration { nanos: -self.nanos };
    }
}

// —————————————————————————————————————————————
// Instant (monotone)
// —————————————————————————————————————————————

public struct Instant {
    ticks: u128   // ticks monotones (ns depuis boot ou ref interne)
}

impl Instant {
    public fn now() -> Instant {
        return Instant { ticks: sys::monotonic_time_ns() };
    }

    public fn elapsed(self: &Instant) -> Duration {
        let now = sys::monotonic_time_ns();
        return Duration { nanos: (now as i128) - (self.ticks as i128) };
    }

    public fn duration_since(self: &Instant, earlier: &Instant) -> Duration {
        return Duration { nanos: (self.ticks as i128) - (earlier.ticks as i128) };
    }
}

// —————————————————————————————————————————————
// SystemTime (Unix time)
// —————————————————————————————————————————————

public struct SystemTime {
    secs: i64,   // secondes depuis Unix epoch (1970-01-01 UTC)
    nanos: i32   // nanosecondes [0, 1e9)
}

impl SystemTime {
    public fn now() -> SystemTime {
        let ns = sys::system_time_ns(); // ns depuis epoch
        let s = (ns / 1_000_000_000) as i64;
        let n = (ns % 1_000_000_000) as i32;
        return SystemTime { secs: s, nanos: n };
    }

    public fn duration_since(self: &SystemTime, earlier: &SystemTime) -> Duration {
        let da = (self.secs as i128 * 1_000_000_000 + self.nanos as i128);
        let db = (earlier.secs as i128 * 1_000_000_000 + earlier.nanos as i128);
        return Duration { nanos: da - db };
    }

    public fn to_unix_ns(self: &SystemTime) -> i128 {
        return (self.secs as i128) * 1_000_000_000 + (self.nanos as i128);
    }
}

// —————————————————————————————————————————————
// DateTime rudimentaire (UTC)
// —————————————————————————————————————————————

public struct DateTime {
    year:  i32,
    month: u8,   // 1–12
    day:   u8,   // 1–31
    hour:  u8,   // 0–23
    min:   u8,   // 0–59
    sec:   u8,   // 0–59
    nanos: u32
}

// Conversion basique Unix -> DateTime UTC (algorithme civil)
// NB : volontairement simplifié (proleptic Gregorian)
impl DateTime {
    public fn from_system_time(st: &SystemTime) -> DateTime {
        let mut days = st.secs / 86400;
        let mut secs_day = st.secs % 86400;
        if secs_day < 0 { secs_day += 86400; days -= 1; }

        let year = 1970; // TODO: calcul complet (Zeller ou algo UTC civil)
        return DateTime { year, month: 1, day: 1,
                          hour: (secs_day / 3600) as u8,
                          min: ((secs_day / 60) % 60) as u8,
                          sec: (secs_day % 60) as u8,
                          nanos: st.nanos as u32 };
    }

    public fn to_string(self: &DateTime) -> String {
        // Format rudimentaire : YYYY-MM-DD HH:MM:SS
        let s = String::new();
        s.push_fmt(self.year, "-", self.month, "-", self.day,
                   " ", self.hour, ":", self.min, ":", self.sec);
        return s;
    }
}

