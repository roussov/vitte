// std/modules/algo/search.vitte
// Algorithmes de recherche : linéaire, binaire, expo, jump, KMP (substring).
// Hypothèses : pour les recherches binaires, les tableaux sont triés (non décroissant).

module std.algo.search

// ————————————————————————————————————————————————————————————————————————
// Utils
// ————————————————————————————————————————————————————————————————————————

pub fn is_sorted_non_decreasing(a: &Vec<i64>) -> bool {
    if a.len() <= 1 { return true }
    let mut i = 1
    while i < a.len() {
        if a[i] < a[i-1] { return false }
        i += 1
    }
    return true
}

fn assert_range(len: i32, lo: i32, hi: i32) {
    if lo < 0 || hi < lo || hi > len {
        panic("range out of bounds: [" + lo.to_string() + "," + hi.to_string() + ") len=" + len.to_string())
    }
}

// ————————————————————————————————————————————————————————————————————————
// Recherche linéaire
// ————————————————————————————————————————————————————————————————————————

pub fn linear_search(a: &Vec<i64>, x: i64) -> i32 {
    let mut i = 0
    while i < a.len() {
        if a[i] == x { return i }
        i += 1
    }
    return -1
}

pub fn linear_search_range(a: &Vec<i64>, lo: i32, hi: i32, x: i64) -> i32 {
    assert_range(a.len(), lo, hi)
    let mut i = lo
    while i < hi {
        if a[i] == x { return i }
        i += 1
    }
    return -1
}

// ————————————————————————————————————————————————————————————————————————
// Recherche binaire (tableau trié non décroissant)
// ————————————————————————————————————————————————————————————————————————

/// Renvoie l’index de x, ou -1 si absent.
pub fn binary_search(a: &Vec<i64>, x: i64) -> i32 {
    return binary_search_range(a, 0, a.len(), x)
}

pub fn binary_search_range(a: &Vec<i64>, mut lo: i32, mut hi: i32, x: i64) -> i32 {
    assert_range(a.len(), lo, hi)
    while lo < hi {
        let mid = lo + (hi - lo) / 2
        let v = a[mid]
        if v == x {
            return mid
        } else if v < x {
            lo = mid + 1
        } else {
            hi = mid
        }
    }
    return -1
}

/// lower_bound: premier index i tel que a[i] >= x (ou a.len() si tout < x)
pub fn lower_bound(a: &Vec<i64>, x: i64) -> i32 {
    return lower_bound_range(a, 0, a.len(), x)
}
pub fn lower_bound_range(a: &Vec<i64>, mut lo: i32, mut hi: i32, x: i64) -> i32 {
    assert_range(a.len(), lo, hi)
    while lo < hi {
        let mid = lo + (hi - lo) / 2
        if a[mid] < x { lo = mid + 1 } else { hi = mid }
    }
    return lo
}

/// upper_bound: premier index i tel que a[i] > x (ou a.len() si tout <= x)
pub fn upper_bound(a: &Vec<i64>, x: i64) -> i32 {
    return upper_bound_range(a, 0, a.len(), x)
}
pub fn upper_bound_range(a: &Vec<i64>, mut lo: i32, mut hi: i32, x: i64) -> i32 {
    assert_range(a.len(), lo, hi)
    while lo < hi {
        let mid = lo + (hi - lo) / 2
        if a[mid] <= x { lo = mid + 1 } else { hi = mid }
    }
    return lo
}

/// partition_point: premier i dans [lo,hi) tel que pred(a[i]) == false → true bascule.
/// Ici, on passe un seuil x et on décide via a[i] < x.
pub fn partition_point_lt(a: &Vec<i64>, lo: i32, hi: i32, x: i64) -> i32 {
    assert_range(a.len(), lo, hi)
    let mut l = lo
    let mut r = hi
    while l < r {
        let m = l + (r - l) / 2
        if a[m] < x { l = m + 1 } else { r = m }
    }
    return l
}

// ————————————————————————————————————————————————————————————————————————
// Recherche exponentielle (pour tableaux triés, utile si taille inconnue / très grande)
// ————————————————————————————————————————————————————————————————————————

pub fn exponential_search(a: &Vec<i64>, x: i64) -> i32 {
    if a.len() == 0 { return -1 }
    if a[0] == x { return 0 }
    let mut bound: i32 = 1
    while bound < a.len() && a[bound] < x {
        bound *= 2
    }
    let lo = bound / 2
    let hi = if bound < a.len() { bound + 1 } else { a.len() }
    return binary_search_range(a, lo, hi, x)
}

// ————————————————————————————————————————————————————————————————————————
// Jump search (tableau trié). O(√n) comparisons.
// ————————————————————————————————————————————————————————————————————————

pub fn jump_search(a: &Vec<i64>, x: i64) -> i32 {
    let n = a.len()
    if n == 0 { return -1 }
    // step ~ floor(sqrt(n))
    let mut step = 1
    while (step + 1) * (step + 1) <= n { step += 1 }

    let mut prev = 0
    let mut cur = step
    while prev < n && a[min(cur, n) - 1] < x {
        prev = cur
        cur += step
        if prev >= n { return -1 }
    }
    // linéaire dans le bloc
    let end = min(cur, n)
    let mut i = prev
    while i < end {
        if a[i] == x { return i }
        if a[i] > x { break }
        i += 1
    }
    return -1
}

fn min(a: i32, b: i32) -> i32 { if a < b { a } else { b } }

// ————————————————————————————————————————————————————————————————————————
// Recherche dans tableau trié pivoté (rotated sorted array, sans doublons)
// ————————————————————————————————————————————————————————————————————————

pub fn rotated_binary_search(a: &Vec<i64>, x: i64) -> i32 {
    if a.len() == 0 { return -1 }
    let mut lo = 0
    let mut hi = a.len() - 1
    while lo <= hi {
        let mid = lo + (hi - lo) / 2
        if a[mid] == x { return mid }
        if a[lo] <= a[mid] {
            // gauche triée
            if a[lo] <= x && x < a[mid] {
                hi = mid - 1
            } else {
                lo = mid + 1
            }
        } else {
            // droite triée
            if a[mid] < x && x <= a[hi] {
                lo = mid + 1
            } else {
                hi = mid - 1
            }
        }
    }
    return -1
}

// ————————————————————————————————————————————————————————————————————————
// KMP — recherche de sous-séquence (pattern) dans un texte (Vec<u8>)
// Renvoie l’index du premier match, ou -1.
// ————————————————————————————————————————————————————————————————————————

pub fn kmp_search(text: &Vec<u8>, pat: &Vec<u8>) -> i32 {
    if pat.len() == 0 { return 0 }
    if text.len() < pat.len() { return -1 }
    let lps = kmp_build_lps(pat)
    let mut i = 0 // index texte
    let mut j = 0 // index pattern

    while i < text.len() {
        if text[i] == pat[j] {
            i += 1
            j += 1
            if j == pat.len() {
                return i - j
            }
        } else {
            if j != 0 {
                j = lps[j - 1]
            } else {
                i += 1
            }
        }
    }
    return -1
}

pub fn kmp_find_all(text: &Vec<u8>, pat: &Vec<u8>) -> Vec<i32> {
    let mut out = Vec<i32>::new()
    if pat.len() == 0 {
        // par convention : match à chaque position 0..text.len()
        let mut i = 0
        while i <= text.len() {
            out.push(i)
            i += 1
        }
        return out
    }
    if text.len() < pat.len() { return out }

    let lps = kmp_build_lps(pat)
    let mut i = 0
    let mut j = 0
    while i < text.len() {
        if text[i] == pat[j] {
            i += 1
            j += 1
            if j == pat.len() {
                out.push(i - j)
                j = lps[j - 1]
            }
        } else {
            if j != 0 {
                j = lps[j - 1]
            } else {
                i += 1
            }
        }
    }
    return out
}

// construit le tableau LPS (longest proper prefix which is also suffix)
fn kmp_build_lps(p: &Vec<u8>) -> Vec<i32> {
    let m = p.len()
    let mut lps = Vec<i32>::with_len(m as usize, 0)
    let mut len = 0
    let mut i = 1
    while i < m {
        if p[i] == p[len] {
            len += 1
            lps[i] = len
            i += 1
        } else {
            if len != 0 {
                len = lps[len - 1]
            } else {
                lps[i] = 0
                i += 1
            }
        }
    }
    return lps
}

// ————————————————————————————————————————————————————————————————————————
// Tests
// ————————————————————————————————————————————————————————————————————————

test "linear basic" {
    let a = [4,2,7,2,9]
    assert linear_search(a, 7) == 2
    assert linear_search(a, 5) == -1
}

test "binary & bounds" {
    let a = [1,2,2,2,5,9]
    assert is_sorted_non_decreasing(a)
    assert binary_search(a, 5) == 4
    assert binary_search(a, 3) == -1
    assert lower_bound(a, 2) == 1
    assert upper_bound(a, 2) == 4
    assert partition_point_lt(a, 0, a.len(), 5) == 4
}

test "exponential & jump" {
    let a = [1,3,5,7,9,11,13,15,17,19]
    assert exponential_search(a, 13) == 6
    assert exponential_search(a, 4) == -1
    assert jump_search(a, 15) == 7
    assert jump_search(a, 2) == -1
}

test "rotated binary search" {
    let a = [7,8,9,1,2,3,4,5,6]
    assert rotated_binary_search(a, 3) == 5
    assert rotated_binary_search(a, 7) == 0
    assert rotated_binary_search(a, 10) == -1
}

test "kmp single & all" {
    let text = "abracadabra".as_bytes()
    let pat  = "abra".as_bytes()
    assert kmp_search(text, pat) == 0
    let all = kmp_find_all(text, pat)
    // "abra" à 0 et 7
    assert all.len() == 2
    assert all[0] == 0 && all[1] == 7
}

test "kmp edge cases" {
    let text = "aaaaa".as_bytes()
    let pat  = "aaa".as_bytes()
    let all = kmp_find_all(text, pat)
    // recouvrements: 0,1,2
    assert all.len() == 3
    assert all[0] == 0 && all[1] == 1 && all[2] == 2
    assert kmp_search("abc".as_bytes(), "d".as_bytes()) == -1
    assert kmp_search("xyz".as_bytes(), "".as_bytes()) == 0
}
