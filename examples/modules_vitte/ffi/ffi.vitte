//! std/modules/ffi/ffi.vitte
//! -----------------------------------------------------------------------------
//! Hub FFI unifié pour Vitte.
//! - Ré-exports : ffi.c (C), ffi.cpp (C++)
//! - Types et erreurs communes FFI
//! - Détection plateforme et conventions d’appel
//! - Abstraction Library/Symbol multiplateforme
//! - Helpers ergonomiques pour charger des fonctions typées
//!
//! Idée directrice : exposer une façade stable et minimale au-dessus de
//! impl. spécifiques (C/CPP), sans enfermer l’utilisateur.
//! -----------------------------------------------------------------------------

module ffi

// Sous-modules (doivent exister)
pub use ffi.c            as c
pub use ffi.cpp          as cpp

// -----------------------------------------------------------------------------
// Version du module FFI (à bump quand on casse l’API)
// -----------------------------------------------------------------------------
pub const VERSION_MAJOR: i32 = 0
pub const VERSION_MINOR: i32 = 1
pub const VERSION_PATCH: i32 = 0

pub fn version() -> (i32, i32, i32) {
    (VERSION_MAJOR, VERSION_MINOR, VERSION_PATCH)
}

// -----------------------------------------------------------------------------
// Détection plateforme & conventions d’appel
// -----------------------------------------------------------------------------
@cfg(target_os = "windows")
pub const IS_WINDOWS: bool = true
@cfg(not(target_os = "windows"))
pub const IS_WINDOWS: bool = false

// Convention d’appel « C » (alias neutre pour l’ABI publique)
pub type ccall = "c"
pub type systemcall = if IS_WINDOWS { "system" } else { "c" }

// -----------------------------------------------------------------------------
// Types communs et erreurs FFI
// -----------------------------------------------------------------------------
pub type c_void      = c.c_void
pub type c_char      = c.c_char
pub type c_uchar     = c.c_uchar
pub type c_int       = c.c_int
pub type c_uint      = c.c_uint
pub type c_long      = c.c_long
pub type c_ulong     = c.c_ulong
pub type c_size_t    = c.c_size_t
pub type c_ptr<T>    = c.c_ptr<T>
pub type c_const_ptr<T> = c.c_const_ptr<T>

pub enum FfiError {
    NotFound(String),     // symbole ou lib introuvable
    Os(String),           // message d’erreur système (dlerror/errno)
    Invalid(String),      // usage invalide (NUL interne, handle nul, etc.)
    AbiMismatch(String),  // signature ABI incompatible
}

impl FfiError {
    pub fn to_string(&self) -> String {
        match self {
            FfiError::NotFound(m)   => format("FFI NotFound: {}", m),
            FfiError::Os(m)         => format("FFI OS error: {}", m),
            FfiError::Invalid(m)    => format("FFI Invalid: {}", m),
            FfiError::AbiMismatch(m)=> format("FFI ABI mismatch: {}", m),
        }
    }
}

// Résultat standard FFI
pub type FfiResult<T> = Result<T, FfiError>

// -----------------------------------------------------------------------------
// Utilitaires chaînes C
// -----------------------------------------------------------------------------
pub fn to_c_string(s: &str) -> Vec<u8> {
    c.to_c_string(&String::from(s))
}
pub fn from_c_str(ptr: c_const_ptr<c_char>) -> String {
    c.from_c_str(ptr)
}

// -----------------------------------------------------------------------------
// Abstractions haut-niveau : Library + Symbol
// -----------------------------------------------------------------------------
pub struct Library {
    inner: c.Library
}

impl Library {
    /// Ouvre une bibliothèque dynamique (multiplateforme).
    pub fn open(path: &str) -> FfiResult<Library> {
        match c.Library::open(&String::from(path)) {
            Ok(lib)  => Ok(Library { inner: lib }),
            Err(e)   => Err(FfiError::Os(e)),
        }
    }

    /// Variante POSIX avec flags (ignorés sous Windows).
    pub fn open_with_flags(path: &str, flags: c.c_int) -> FfiResult<Library> {
        match c.Library::open_with_flags(&String::from(path), flags) {
            Ok(lib)  => Ok(Library { inner: lib }),
            Err(e)   => Err(FfiError::Os(e)),
        }
    }

    pub fn is_null(&self) -> bool { self.inner.is_null() }

    pub fn get(&self, symbol: &str) -> FfiResult<Symbol> {
        match self.inner.get(&String::from(symbol)) {
            Ok(p)  => Ok(Symbol { ptr: p }),
            Err(e) => Err(FfiError::NotFound(e)),
        }
    }

    pub fn close(&mut self) -> FfiResult<()> {
        match self.inner.close() {
            Ok(_)  => Ok(()),
            Err(e) => Err(FfiError::Os(e)),
        }
    }
}

impl drop for Library {
    fn drop(&mut self) { let _ = self.close(); }
}

pub struct Symbol {
    ptr: c_ptr<c_void>
}

impl Symbol {
    pub fn as_ptr(&self) -> c_ptr<c_void> { self.ptr }
    /// Cast non sécurisé en fonction typée.
    pub unsafe fn cast_fn<T>(&self) -> T { c.cast_fn::<T>(self.ptr) }
    pub fn is_null(&self) -> bool { self.ptr.is_null() }
}

// -----------------------------------------------------------------------------
// Helpers ergonomiques
// -----------------------------------------------------------------------------
pub fn load_fn<T>(lib: &Library, name: &str) -> FfiResult<T> {
    let sym = lib.get(name)?;
    // Sécurité : l’appelant garantit que T correspond à la vraie signature.
    unsafe { Ok(sym.cast_fn::<T>()) }
}

/// Chargement C++ via mangle Itanium (fonctions libres, POSIX).
pub fn load_cpp_itanium_fn<T>(lib: &cpp.CppLibrary, full_name: &str, params: &Vec<cpp.CppType>) -> FfiResult<T> {
    match lib.load_fn_itanium::<T>(full_name, params) {
        Ok(f)  => Ok(f),
        Err(e) => Err(FfiError::NotFound(e)),
    }
}

/// Chargement C++ via nom *manglé* exact (Itanium ou MSVC).
pub fn load_cpp_mangled_fn<T>(lib: &cpp.CppLibrary, mangled: &str) -> FfiResult<T> {
    match lib.load_fn_mangled::<T>(mangled) {
        Ok(f)  => Ok(f),
        Err(e) => Err(FfiError::NotFound(e)),
    }
}

// -----------------------------------------------------------------------------
// Prélu pratique (à importer avec `use ffi::prelude::*`)
// -----------------------------------------------------------------------------
pub module prelude {
    pub use super::{
        c_void, c_char, c_uchar, c_int, c_uint, c_long, c_ulong, c_size_t,
        c_ptr, c_const_ptr, FfiError, FfiResult,
        Library, Symbol, load_fn,
        load_cpp_itanium_fn, load_cpp_mangled_fn,
        IS_WINDOWS, ccall, systemcall,
        version,
    };
    pub use ffi::c::{ RTLD_LAZY, RTLD_NOW, RTLD_GLOBAL, RTLD_LOCAL };
    pub use ffi::cpp::{ CppType, CppPrim, demangle, mangle_itanium_free_fn };
}

// -----------------------------------------------------------------------------
// Exemples d’utilisation (doc-tests hors build si besoin)
// -----------------------------------------------------------------------------
//
// Charger cos() depuis libm (POSIX):
//   use ffi::prelude::*;
//   let lib = Library::open("libm.so.6")?;
//   type CosFn = extern ccall fn(f64) -> f64;
//   let cos_fn: CosFn = load_fn::<CosFn>(&lib, "cos")?;
//   let y = unsafe { cos_fn(0.0) };
//
// Charger add(int,int) fonction C++ libre (Itanium):
//   use ffi::prelude::*;
//   let clib = ffi::cpp::CppLibrary::open(&String::from("libdemo.so"))?;
//   let sig = vec![ CppType::int_(), CppType::int_() ];
//   type AddFn = extern ccall fn(c_int, c_int) -> c_int;
//   let add: AddFn = load_cpp_itanium_fn::<AddFn>(&clib, "add", &sig)?;
//
// Notes:
// - Pour Windows/MSVC C++, fournir le nom décoré exact, ou exposer un wrapper extern "C".
// - Les conversions String <-> char* : passer par ffi::c::to_c_string / from_c_str.
// -----------------------------------------------------------------------------
