//! std/modules/ffi/cpp/ffi_cpp.vitte
//! -----------------------------------------------------------------------------
//! FFI C++ — utilitaires pour interagir avec des symboles C++ depuis Vitte.
//!
//! • Démangling :
//!     - POSIX (Itanium): abi::__cxa_demangle
//!     - Windows (MSVC) : UnDecorateSymbolNameA (dbghelp)
//! • Mangleur Itanium (subset robuste) pour fonctions "free" (globales ou namespaces)
//! • CppLibrary : enveloppe au-dessus de ffi.c::Library pour charger des symboles C++
//! • Helpers typés : load_fn_mangled<T>, load_fn_itanium<T>
//!
//! ⚠️ Recommandation pro : pour exposer des API C++ stables, fournissez des
//! wrappers `extern "C"` côté C++ (types C only). Le mangleur ici sert surtout
//! à du tooling, de l’exploration et des cas simples.
//! -----------------------------------------------------------------------------

module ffi.cpp
use ffi.c as c

// -----------------------------------------------------------------------------
// Sélection plateforme locale
// -----------------------------------------------------------------------------
@cfg(target_os = "windows")
const IS_WINDOWS: bool = true
@cfg(not(target_os = "windows"))
const IS_WINDOWS: bool = false

// -----------------------------------------------------------------------------
// Démangling
// -----------------------------------------------------------------------------
@cfg(not(target_os = "windows"))
extern "c" {
    // abi::__cxa_demangle(const char*, char*, size_t*, int*) -> char*
    pub fn __cxa_demangle(
        mangled: c.c_const_ptr<c.c_char>,
        out_buf: c.c_ptr<c.c_char>,
        out_len: c.c_ptr<c.c_size_t>,
        status: c.c_ptr<c.c_int>
    ) -> c.c_ptr<c.c_char>
}

@cfg(target_os = "windows")
extern "system" {
    // dbghelp!UnDecorateSymbolNameA
    pub fn UnDecorateSymbolNameA(
        name: c.c_const_ptr<c.c_char>,
        out:  c.c_ptr<c.c_char>,
        out_size: c.c_uint,
        flags: c.c_uint
    ) -> c.c_uint
}

// Flags utiles (MSVC dbghelp). 0 par défaut fonctionne généralement.
@cfg(target_os = "windows")
pub const UNDNAME_COMPLETE: c.c_uint = 0x0000

/// Démangle un nom décoré C++ en représentation lisible.
/// Si échec, renvoie la chaîne d’origine.
pub fn demangle(mangled: &str) -> String {
    let cstr = c.to_c_string(&String::from(mangled));
    if IS_WINDOWS {
        // Buffer raisonnable (4 KiB)
        let mut buf = vec![0u8; 4096];
        let written = unsafe {
            UnDecorateSymbolNameA(
                cstr.as_ptr() as c.c_const_ptr<c.c_char>,
                buf.as_mut_ptr() as c.c_ptr<c.c_char>,
                4096 as c.c_uint,
                UNDNAME_COMPLETE
            )
        };
        if written == 0 {
            return String::from(mangled);
        } else {
            // tronque au NUL
            return c.from_c_str(buf.as_ptr() as c.c_const_ptr<c.c_char>);
        }
    } else {
        let mut out_len: c.c_size_t = 0;
        let mut status: c.c_int = 0;
        let dem = unsafe {
            __cxa_demangle(
                cstr.as_ptr() as c.c_const_ptr<c.c_char>,
                0 as c.c_ptr<c.c_char>, &mut out_len, &mut status
            )
        };
        if dem.is_null() || status != 0 {
            return String::from(mangled);
        }
        let out = c.from_c_str(dem as c.c_const_ptr<c.c_char>);
        // __cxa_demangle -> malloc ; on libère via free
        c.c_free(dem as c.c_ptr<c.c_void>);
        out
    }
}

// -----------------------------------------------------------------------------
// Description minimale de types C++ (Itanium ABI)
// -----------------------------------------------------------------------------
pub enum CppPrim {
    Void, Bool, Char, SChar, UChar,
    Short, UShort, Int, UInt,
    Long, ULong, LongLong, ULongLong,
    Float, Double, LongDouble,
    WChar, Char16, Char32
}

pub enum CppType {
    Prim(CppPrim),
    Ptr(Box<CppType>),
    Ref(Box<CppType>),     // lvalue ref
    RRef(Box<CppType>),    // rvalue ref
    Const(Box<CppType>),
    Volatile(Box<CppType>),
}

impl CppType {
    pub fn prim(p: CppPrim) -> CppType { CppType::Prim(p) }
    pub fn void() -> CppType { CppType::Prim(CppPrim::Void) }
    pub fn bool() -> CppType { CppType::Prim(CppPrim::Bool) }
    pub fn char() -> CppType { CppType::Prim(CppPrim::Char) }
    pub fn schar() -> CppType { CppType::Prim(CppPrim::SChar) }
    pub fn uchar() -> CppType { CppType::Prim(CppPrim::UChar) }
    pub fn short() -> CppType { CppType::Prim(CppPrim::Short) }
    pub fn ushort() -> CppType { CppType::Prim(CppPrim::UShort) }
    pub fn int_() -> CppType { CppType::Prim(CppPrim::Int) }
    pub fn uint() -> CppType { CppType::Prim(CppPrim::UInt) }
    pub fn long_() -> CppType { CppType::Prim(CppPrim::Long) }
    pub fn ulong() -> CppType { CppType::Prim(CppPrim::ULong) }
    pub fn llong() -> CppType { CppType::Prim(CppPrim::LongLong) }
    pub fn ullong() -> CppType { CppType::Prim(CppPrim::ULongLong) }
    pub fn float_() -> CppType { CppType::Prim(CppPrim::Float) }
    pub fn double_() -> CppType { CppType::Prim(CppPrim::Double) }
    pub fn ldouble() -> CppType { CppType::Prim(CppPrim::LongDouble) }
    pub fn wchar() -> CppType { CppType::Prim(CppPrim::WChar) }
    pub fn char16() -> CppType { CppType::Prim(CppPrim::Char16) }
    pub fn char32() -> CppType { CppType::Prim(CppPrim::Char32) }

    pub fn ptr(t: CppType) -> CppType { CppType::Ptr(Box::new(t)) }
    pub fn r#ref(t: CppType) -> CppType { CppType::Ref(Box::new(t)) }
    pub fn rref(t: CppType) -> CppType { CppType::RRef(Box::new(t)) }
    pub fn cst(t: CppType) -> CppType { CppType::Const(Box::new(t)) }
    pub fn vol(t: CppType) -> CppType { CppType::Volatile(Box::new(t)) }
}

// Encodage Itanium des types (subset largement suffisant pour les basiques)
fn encode_itanium_type(t: &CppType, out: &mut String) {
    match t {
        CppType::Prim(p) => {
            let code = match p {
                CppPrim::Void       => "v",
                CppPrim::Bool       => "b",
                CppPrim::Char       => "c",
                CppPrim::SChar      => "a",
                CppPrim::UChar      => "h",
                CppPrim::Short      => "s",
                CppPrim::UShort     => "t",
                CppPrim::Int        => "i",
                CppPrim::UInt       => "j",
                CppPrim::Long       => "l",
                CppPrim::ULong      => "m",
                CppPrim::LongLong   => "x",
                CppPrim::ULongLong  => "y",
                CppPrim::Float      => "f",
                CppPrim::Double     => "d",
                CppPrim::LongDouble => "e",
                CppPrim::WChar      => "w",
                CppPrim::Char16     => "Ds", // Itanium : char16_t -> u16 alias ; ici indicatif
                CppPrim::Char32     => "Di", // char32_t -> u32 alias ; indicatif
            };
            out.push_str(code);
        }
        CppType::Ptr(inner) => { out.push('P'); encode_itanium_type(inner, out); }
        CppType::Ref(inner) => { out.push('R'); encode_itanium_type(inner, out); }
        CppType::RRef(inner)=> { out.push('O'); encode_itanium_type(inner, out); }
        CppType::Const(inner)=>{ out.push('K'); encode_itanium_type(inner, out); }
        CppType::Volatile(i)=>{ out.push('V'); encode_itanium_type(i, out); }
    }
}

// Mangleur Itanium pour fonction libre (global ou namespacée).
// `full_name` peut contenir "ns1::ns2::func".
pub fn mangle_itanium_free_fn(full_name: &str, params: &Vec<CppType>) -> String {
    // Split namespaces
    let parts = split_cpp_name(full_name);
    let mut s = String::from("_Z");
    if parts.len() == 1 {
        let name = &parts[0];
        s.push_str(&format("{}{}", name.len(), name));
    } else {
        s.push('N');
        for p in parts.iter() {
            s.push_str(&format("{}{}", p.len(), p));
        }
        s.push('E');
    }
    if params.len() == 0 {
        s.push('v'); // liste vide -> 'v'
    } else {
        for t in params.iter() {
            encode_itanium_type(t, &mut s);
        }
    }
    s
}

fn split_cpp_name(full_name: &str) -> Vec<String> {
    // Découpe par "::"
    let mut out = Vec::<String>::new();
    let mut cur = String::new();
    let chars = full_name.chars().collect::<Vec<char>>();
    let n = chars.len();
    let mut i = 0;
    while i < n {
        if i + 1 < n && chars[i] == ':' && chars[i+1] == ':' {
            out.push(cur.clone()); cur.clear(); i += 2; continue;
        } else {
            cur.push(chars[i]); i += 1;
        }
    }
    if cur.len() > 0 { out.push(cur); }
    out
}

// -----------------------------------------------------------------------------
// Abstraction CppLibrary
// -----------------------------------------------------------------------------
pub struct CppLibrary {
    inner: c.Library
}

impl CppLibrary {
    pub fn open(path: &String) -> Result<CppLibrary, String> {
        let lib = c.Library::open(path)?;
        Ok(CppLibrary { inner: lib })
    }

    pub fn is_null(&self) -> bool { self.inner.is_null() }

    /// Récupère un symbole via son nom *manglé* (MSVC/Itanium).
    pub fn get_mangled(&self, mangled: &str) -> Result<c.c_ptr<c.c_void>, String> {
        self.inner.get(&String::from(mangled))
    }

    /// Récupère un symbole de fonction libre via mangle Itanium (POSIX).
    pub fn get_itanium_free_fn(&self, full_name: &str, params: &Vec<CppType>) -> Result<c.c_ptr<c.c_void>, String> {
        if IS_WINDOWS {
            return Err(String::from("Itanium mangling non supporté sous MSVC. Fournir le nom décoré MSVC."));
        }
        let m = mangle_itanium_free_fn(full_name, params);
        self.get_mangled(&m)
    }

    /// Charge et caste un symbole *manglé* en fonction typée.
    pub fn load_fn_mangled<T>(&self, mangled: &str) -> Result<T, String> {
        let p = self.get_mangled(mangled)?;
        unsafe { Ok(c.cast_fn::<T>(p)) }
    }

    /// Charge et caste une fonction libre via spéc Itanium (POSIX).
    pub fn load_fn_itanium<T>(&self, full_name: &str, params: &Vec<CppType>) -> Result<T, String> {
        let p = self.get_itanium_free_fn(full_name, params)?;
        unsafe { Ok(c.cast_fn::<T>(p)) }
    }

    pub fn close(&mut self) -> Result<(), String> { self.inner.close() }
}

impl drop for CppLibrary {
    fn drop(&mut self) { let _ = self.close(); }
}

// -----------------------------------------------------------------------------
// Exemples d’utilisation (documentation)
// -----------------------------------------------------------------------------
//
// POSIX — charger une fonction C++ libre `int add(int,int)` du binaire C++:
//   // C++ (libdemo.so):
//   //   int add(int a, int b) { return a + b; }
//   //   // pas d'extern "C" -> symbole manglé Itanium
//
//   let lib = CppLibrary::open(&String::from("libdemo.so")).unwrap();
//   type AddFn = extern "c" fn(c.c_int, c.c_int) -> c.c_int;
//   let sig = vec![ CppType::int_(), CppType::int_() ];
//   let add: AddFn = lib.load_fn_itanium::<AddFn>("add", &sig).unwrap();
//   let r = unsafe { add(2, 40) };
//   assert(r == 42);
//
// Windows/MSVC — il faut le nom décoré exact (ex. "?add@@YAHHH@Z") *ou*
// exposer un wrapper `extern "C"` côté C++ et passer par ffi.c.
//
// Démangling rapide :
//   let human = demangle("_Z3addii"); // -> "int add(int, int)"
//
