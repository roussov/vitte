// modules/core/db/postgres.vitte
// PostgreSQL driver (façade std) — API stable, backend-agnostique.
// Branche un backend FFI (libpq, pqxx, Rust, etc.) en remplaçant les `be_*`.
//
// Features :
//  - connect/close
//  - exec(sql, params) -> rows_affected
//  - query(sql, params) -> PgResult (rows + columns)
//  - transactions: begin/commit/rollback, helpers tx_exec/tx_query
//  - prepared statements: prepare/exec_stmt/query_stmt/finalize
//  - PgValue typé (Null, i32, i64, f64, bool, text, bytes, json)
//  - DSN builder (sslmode, options)
//  - Helpers: query_one, get_* by index or name
//
// Notes :
//  - Ordre des colonnes préservé par le backend.
//  - Encodage params/vals cédé au backend (bin/text) — on passe PgValue taggé.

module core.db.postgres

// ————————————————————————————————————————————————————————————————————————
// Types de valeurs (params / résultats) — tag + union pauvre
// ————————————————————————————————————————————————————————————————————————
const PG_NULL  : i32 = 0
const PG_I32   : i32 = 1
const PG_I64   : i32 = 2
const PG_F64   : i32 = 3
const PG_BOOL  : i32 = 4
const PG_TEXT  : i32 = 5
const PG_BYTES : i32 = 6
const PG_JSON  : i32 = 7

pub struct PgValue {
    t:   i32,
    i32: i32,
    i64: i64,
    f64: f64,
    b:   bool,
    s:   String,
    bin: Vec<u8>,
}

pub fn v_null()         -> PgValue { return PgValue{t:PG_NULL,  i32:0, i64:0, f64:0.0, b:false, s:"".to_string(), bin:Vec<u8>::new()} }
pub fn v_i32(x: i32)    -> PgValue { return PgValue{t:PG_I32,   i32:x, i64:0, f64:0.0, b:false, s:"".to_string(), bin:Vec<u8>::new()} }
pub fn v_i64(x: i64)    -> PgValue { return PgValue{t:PG_I64,   i32:0, i64:x, f64:0.0, b:false, s:"".to_string(), bin:Vec<u8>::new()} }
pub fn v_f64(x: f64)    -> PgValue { return PgValue{t:PG_F64,   i32:0, i64:0, f64:x,   b:false, s:"".to_string(), bin:Vec<u8>::new()} }
pub fn v_bool(x: bool)  -> PgValue { return PgValue{t:PG_BOOL,  i32:0, i64:0, f64:0.0, b:x,     s:"".to_string(), bin:Vec<u8>::new()} }
pub fn v_text(x: &str)  -> PgValue { return PgValue{t:PG_TEXT,  i32:0, i64:0, f64:0.0, b:false, s:x.to_string(),  bin:Vec<u8>::new()} }
pub fn v_bytes(x: &Vec<u8>) -> PgValue { return PgValue{t:PG_BYTES, i32:0, i64:0, f64:0.0, b:false, s:"".to_string(), bin:x.clone()} }
pub fn v_json(x: &str)  -> PgValue { return PgValue{t:PG_JSON,  i32:0, i64:0, f64:0.0, b:false, s:x.to_string(),  bin:Vec<u8>::new()} }

// ————————————————————————————————————————————————————————————————————————
// Résultats
// ————————————————————————————————————————————————————————————————————————
pub struct PgResult {
    columns: Vec<String>,
    rows:    Vec<Vec<PgValue>>,
}

pub struct PgRow {
    cols: Vec<PgValue>,
    names: Vec<String>,
}

pub fn row_count(r: &PgResult) -> i32 { return r.rows.len() }
pub fn col_count(r: &PgResult) -> i32 { return r.columns.len() }

pub fn get_row(r: &PgResult, i: i32) -> PgRow {
    return PgRow { cols: r.rows[i].clone(), names: r.columns.clone() }
}

pub fn row_get(row: &PgRow, idx: i32) -> PgValue { return row.cols[idx].clone() }
pub fn row_get_by_name(row: &PgRow, name: &str) -> PgValue {
    let mut i = 0
    while i < row.names.len() {
        if row.names[i].eq_ignore_ascii_case(name) { return row.cols[i].clone() }
        i += 1
    }
    panic("postgres: column not found: " + name)
}

// Conversions rapides (panic si type inattendu)
pub fn as_i32(v: &PgValue) -> i32  { if v.t==PG_I32 { return v.i32 }  else { panic("pg: not i32") } }
pub fn as_i64(v: &PgValue) -> i64  { if v.t==PG_I64 { return v.i64 }  else { panic("pg: not i64") } }
pub fn as_f64(v: &PgValue) -> f64  { if v.t==PG_F64 { return v.f64 }  else { panic("pg: not f64") } }
pub fn as_bool(v:&PgValue)-> bool  { if v.t==PG_BOOL{ return v.b }    else { panic("pg: not bool") } }
pub fn as_text(v:&PgValue)-> String{ if v.t==PG_TEXT||v.t==PG_JSON { return v.s.clone() } else { panic("pg: not text/json") } }
pub fn as_bytes(v:&PgValue)->Vec<u8>{ if v.t==PG_BYTES { return v.bin.clone() } else { panic("pg: not bytes") } }
pub fn is_null(v:&PgValue) -> bool { return v.t == PG_NULL }

// ————————————————————————————————————————————————————————————————————————
// Connexion & pool minimal
// ————————————————————————————————————————————————————————————————————————
pub struct PgConn {
    handle: i64,
    open:   bool,
}

pub fn connect(dsn: &str) -> PgConn {
    let h = be_connect(dsn)
    return PgConn { handle: h, open: true }
}

pub fn close(c: &mut PgConn) {
    if !c.open { return }
    be_close(c.handle)
    c.open = false
}

fn ensure(c: &PgConn) {
    if !c.open { panic("postgres: connection is closed") }
}

// ————————————————————————————————————————————————————————————————————————
// Exec & Query (non préparés)
// ————————————————————————————————————————————————————————————————————————
pub fn exec(c: &mut PgConn, sql: &str, params: &Vec<PgValue>) -> i64 {
    ensure(c)
    return be_exec(c.handle, sql, params)
}

pub fn query(c: &mut PgConn, sql: &str, params: &Vec<PgValue>) -> PgResult {
    ensure(c)
    return be_query(c.handle, sql, params)
}

pub fn query_one(c: &mut PgConn, sql: &str, params: &Vec<PgValue>) -> Option<PgRow> {
    let r = query(c, sql, params)
    if r.rows.len() == 0 { return None }
    return Some(get_row(r, 0))
}

// ————————————————————————————————————————————————————————————————————————
// Transactions
// ————————————————————————————————————————————————————————————————————————
pub struct PgTx {
    handle: i64,
    active: bool,
}

pub fn begin(c: &mut PgConn) -> PgTx {
    ensure(c)
    if !be_begin(c.handle) { panic("postgres: BEGIN failed") }
    return PgTx { handle: c.handle, active: true }
}

pub fn tx_exec(tx: &mut PgTx, sql: &str, params: &Vec<PgValue>) -> i64 {
    if !tx.active { panic("postgres: tx not active") }
    return be_exec(tx.handle, sql, params)
}
pub fn tx_query(tx: &mut PgTx, sql: &str, params: &Vec<PgValue>) -> PgResult {
    if !tx.active { panic("postgres: tx not active") }
    return be_query(tx.handle, sql, params)
}
pub fn commit(tx: &mut PgTx) {
    if !tx.active { return }
    be_commit(tx.handle)
    tx.active = false
}
pub fn rollback(tx: &mut PgTx) {
    if !tx.active { return }
    be_rollback(tx.handle)
    tx.active = false
}

// ————————————————————————————————————————————————————————————————————————
// Prepared statements
// ————————————————————————————————————————————————————————————————————————
pub struct PgStmt {
    handle: i64,   // conn handle
    sid:    i64,   // statement id (backend)
    sql:    String,
    cols:   Vec<String>, // optionnel (peut rester vide avant 1er query)
}

pub fn prepare(c: &mut PgConn, sql: &str) -> PgStmt {
    ensure(c)
    let sid = be_prepare(c.handle, sql)
    return PgStmt { handle:c.handle, sid, sql: sql.to_string(), cols: Vec<String>::new() }
}
pub fn finalize(stmt: &mut PgStmt) {
    be_finalize_stmt(stmt.handle, stmt.sid)
    stmt.sid = 0
}
pub fn exec_stmt(stmt: &mut PgStmt, params: &Vec<PgValue>) -> i64 {
    return be_exec_prepared(stmt.handle, stmt.sid, params)
}
pub fn query_stmt(stmt: &mut PgStmt, params: &Vec<PgValue>) -> PgResult {
    let r = be_query_prepared(stmt.handle, stmt.sid, params)
    if stmt.cols.len()==0 { stmt.cols = r.columns.clone() }
    return r
}

// ————————————————————————————————————————————————————————————————————————
// DSN helpers
// ————————————————————————————————————————————————————————————————————————
pub fn dsn(host: &str, port: i32, db: &str, user: &str, password: &str, sslmode: &str, options: &str) -> String {
    // Exemple: postgres://user:pass@host:5432/db?sslmode=disable&application_name=vitte
    let mut u = "postgres://".to_string()
    u.push_str(user)
    if password.len()>0 { u.push(':'); u.push_str(password) }
    u.push('@'); u.push_str(host); u.push(':'); u.push_str(port.to_string()); u.push('/')
    u.push_str(db)
    let mut sep = '?'
    if sslmode.len()>0 { u.push(sep); u.push_str("sslmode="); u.push_str(sslmode); sep='&' }
    if options.len()>0 { u.push(sep); u.push_str(options); }
    return u
}

// ————————————————————————————————————————————————————————————————————————
// Backend FFI — à implémenter côté runtime (libpq, etc.)
// Les fonctions doivent convertir PgValue <-> formats PG, et remplir PgResult.
// ————————————————————————————————————————————————————————————————————————
fn be_connect(_dsn: &str) -> i64 {
    panic("postgres: no backend linked (be_connect)")
}
fn be_close(_handle: i64) {
    panic("postgres: no backend linked (be_close)")
}
fn be_exec(_handle: i64, _sql: &str, _params: &Vec<PgValue>) -> i64 {
    panic("postgres: no backend linked (be_exec)")
}
fn be_query(_handle: i64, _sql: &str, _params: &Vec<PgValue>) -> PgResult {
    panic("postgres: no backend linked (be_query)")
}
fn be_begin(_handle: i64) -> bool {
    panic("postgres: no backend linked (be_begin)")
}
fn be_commit(_handle: i64) {
    panic("postgres: no backend linked (be_commit)")
}
fn be_rollback(_handle: i64) {
    panic("postgres: no backend linked (be_rollback)")
}
fn be_prepare(_handle: i64, _sql: &str) -> i64 {
    panic("postgres: no backend linked (be_prepare)")
}
fn be_finalize_stmt(_handle: i64, _sid: i64) {
    panic("postgres: no backend linked (be_finalize_stmt)")
}
fn be_exec_prepared(_handle: i64, _sid: i64, _params: &Vec<PgValue>) -> i64 {
    panic("postgres: no backend linked (be_exec_prepared)")
}
fn be_query_prepared(_handle: i64, _sid: i64, _params: &Vec<PgValue>) -> PgResult {
    panic("postgres: no backend linked (be_query_prepared)")
}

// ————————————————————————————————————————————————————————————————————————
// Tests (hors I/O) — API surface/erreurs de type
// ————————————————————————————————————————————————————————————————————————
test "pgvalue constructors & accessors" {
    let a = v_i32(7);   assert as_i32(a) == 7
    let b = v_text("yo"); assert as_text(b) == "yo"
    let c = v_bool(true); assert as_bool(c)
    let d = v_null(); assert is_null(d)
}
