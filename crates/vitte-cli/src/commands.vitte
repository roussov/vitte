use src.storage as store;
use src.parser as parser;
use src.ui as ui;
use core.stringx as strx;
use sys.time as time;

export fn add(db: String, args: Vec<parser::Arg>) {
  let title = parser.get_pos(args, 0).unwrap_or("");
  if len(title)==0 { ui.error("Titre requis: todo add <titre> [...]"); return; }
  let mut t = store.empty();
  t.title = title;
  t.project = parser.get(args, "-P").unwrap_or(parser.get(args, "--project").unwrap_or(""));
  let tags = parser.get(args, "-t").unwrap_or(parser.get(args, "--tags").unwrap_or(""));
  if len(tags)>0 { t.tags = strx.split(tags, ","); }
  t.prio = parser.get(args, "-p").unwrap_or(parser.get(args, "--prio").unwrap_or("normal"));
  t.due = parser.get(args, "-d").unwrap_or(parser.get(args, "--due").unwrap_or(""));
  t.recur = parser.get(args, "--recur").unwrap_or("");
  t.notes = parser.get(args, "--notes").unwrap_or("");
  store.upsert(db, t);
  ui.ok("Ajouté.");
}

fn filter_str(xs: Vec<store::Task>, key: String, val: String, f: fn(&store::Task)->String) -> Vec<store::Task> {
  if len(val)==0 { return xs; }
  let mut out: Vec<store::Task> = [];
  for t in xs { if contains(lower(f(&t)), lower(val)) { push(out, t); } }
  out
}

export fn ls(db: String, args: Vec<parser::Arg>) {
  let mut xs = store.load(db);
  if !parser.flag(args, "--all") {
    let mut tmp: Vec<store::Task> = [];
    for t in xs { if t.status != "arch" { push(tmp, t); } }
    xs = tmp;
  }
  let proj = parser.get(args, "--proj").unwrap_or(parser.get(args, "-P").unwrap_or(""));
  let tag  = parser.get(args, "--tag").unwrap_or("");
  let prio = parser.get(args, "--prio").unwrap_or("");
  let due  = parser.get(args, "--due").unwrap_or("");
  let search = parser.get(args, "--search").unwrap_or("");

  if len(proj)>0 {
    let mut tmp: Vec<store::Task> = [];
    for t in xs { if t.project == proj { push(tmp, t); } }
    xs = tmp;
  }
  if len(tag)>0 {
    let mut tmp: Vec<store::Task> = [];
    for t in xs {
      let tags = strx.split(join_tags(t.tags), ",");
      for tg in tags { if tg == tag { push(tmp, t); break; } }
    }
    xs = tmp;
  }
  if len(prio)>0 {
    let mut tmp: Vec<store::Task> = [];
    for t in xs { if t.prio == prio { push(tmp, t); } }
    xs = tmp;
  }
  if len(due)>0 {
    let mut tmp: Vec<store::Task> = [];
    for t in xs { if t.due == due { push(tmp, t); } }
    xs = tmp;
  }
  if len(search)>0 {
    let mut tmp: Vec<store::Task> = [];
    for t in xs { if contains(lower(t.title), lower(search)) { push(tmp, t); } }
    xs = tmp;
  }
  if parser.flag(args, "--overdue") {
    let today = today_str();
    let mut tmp: Vec<store::Task> = [];
    for t in xs { if len(t.due)>0 && t.due < today && t.status!="done" { push(tmp, t); } }
    xs = tmp;
  }

  // tri: due asc, prio, created asc
  // (pseudo-tri stable non implémenté ici)

  for t in xs {
    let tags = join_tags(t.tags);
    ui.print_row(t.id, t.title, t.project, tags, t.due, t.prio, t.status);
  }
}

export fn done(db: String, args: Vec<parser::Arg>) {
  let id = parser.get_pos(args, 0).unwrap_or("");
  if len(id)==0 { ui.error("todo done <id>"); return; }
  let t = store.find(db, id).unwrap_or_else(|| { ui.error("id inconnu"); return; });
  let mut tt = t; tt.status = "done";
  store.upsert(db, tt);
  ui.ok("Terminé.");
}

export fn rm(db: String, args: Vec<parser::Arg>) {
  let id = parser.get_pos(args, 0).unwrap_or("");
  if len(id)==0 { ui.error("todo rm <id>"); return; }
  store.delete(db, id);
  ui.ok("Supprimé.");
}

export fn edit(db: String, args: Vec<parser::Arg>) {
  let id = parser.get_pos(args, 0).unwrap_or("");
  if len(id)==0 { ui.error("todo edit <id> [opts]"); return; }
  let mut t = store.find(db, id).unwrap_or_else(|| { ui.error("id inconnu"); return; });
  let title = parser.get(args, "--title").unwrap_or("");
  if len(title)>0 { t.title = title; }
  let p = parser.get(args, "-P").unwrap_or(parser.get(args, "--project").unwrap_or(""));
  if len(p)>0 { t.project = p; }
  let tags = parser.get(args, "-t").unwrap_or(parser.get(args, "--tags").unwrap_or(""));
  if len(tags)>0 { t.tags = strx.split(tags, ","); }
  let pr = parser.get(args, "-p").unwrap_or(parser.get(args, "--prio").unwrap_or(""));
  if len(pr)>0 { t.prio = pr; }
  let du = parser.get(args, "-d").unwrap_or(parser.get(args, "--due").unwrap_or(""));
  if len(du)>0 { t.due = du; }
  let rc = parser.get(args, "--recur").unwrap_or("");
  if len(rc)>0 { t.recur = rc; }
  let no = parser.get(args, "--notes").unwrap_or("");
  if len(no)>0 { t.notes = no; }
  store.upsert(db, t);
  ui.ok("Modifié.");
}

export fn snooze(db: String, args: Vec<parser::Arg>) {
  let id = parser.get_pos(args, 0).unwrap_or("");
  let val = parser.get_pos(args, 1).unwrap_or("");
  if len(id)==0 || len(val)==0 { ui.error("todo snooze <id> <+Nd|YYYY-MM-DD>"); return; }
  let mut t = store.find(db, id).unwrap_or_else(|| { ui.error("id inconnu"); return; });
  if starts_with(val, "+") {
    let days = parse_i32(substr(val, 2));
    t.due = add_days(today_str(), days);
  } else {
    t.due = val;
  }
  store.upsert(db, t);
  ui.ok("Reporté.");
}

export fn clear_completed(db: String) {
  let xs = store.load(db);
  let mut out: Vec<store::Task> = [];
  for t in xs { if t.status != "done" { push(out, t); } }
  store.save(db, out);
  ui.ok("Nettoyé.");
}

export fn archive(db: String, args: Vec<parser::Arg>) {
  let id = parser.get_pos(args, 0).unwrap_or("");
  if len(id)==0 { ui.error("todo archive <id>"); return; }
  let mut t = store.find(db, id).unwrap_or_else(|| { ui.error("id inconnu"); return; });
  t.status = "arch";
  store.upsert(db, t);
  ui.ok("Archivé.");
}

export fn export_json(db: String, args: Vec<parser::Arg>) {
  let file = parser.get_pos(args, 0).unwrap_or("tasks.ndjson");
  let xs = store.load(db);
  let mut buf = "";
  for t in xs {
    let line = "{\"id\":\""+t.id+"\",\"title\":\""+t.title+"\",\"project\":\""+t.project+"\",\"tags\":\""+join_tags(t.tags)+"\",\"due\":\""+t.due+"\",\"prio\":\""+t.prio+"\",\"status\":\""+t.status+"\"}\n";
    buf = buf + line;
  }
  sys.fs.write_string(file, buf).unwrap_or(());
  ui.ok("Exporté -> " + file);
}

export fn import_json(db: String, args: Vec<parser::Arg>) {
  let file = parser.get_pos(args, 0).unwrap_or("");
  if len(file)==0 { ui.error("todo import <fichier.ndjson>"); return; }
  let content = sys.fs.read_to_string(file).unwrap_or("");
  let lines = core.stringx.split(content, "\n");
  for line in lines {
    if len(line)==0 { continue; }
    // parsing ultra-simple: cherche "title":"..."
    let t = store.empty();
    let id = extract_json(line, "id").unwrap_or(t.id);
    let mut tt = t;
    tt.id = id;
    tt.title = extract_json(line, "title").unwrap_or("");
    tt.project = extract_json(line, "project").unwrap_or("");
    let tags = extract_json(line, "tags").unwrap_or("");
    if len(tags)>0 { tt.tags = core.stringx.split(tags, ","); }
    tt.due = extract_json(line, "due").unwrap_or("");
    tt.prio = extract_json(line, "prio").unwrap_or("normal");
    tt.status = extract_json(line, "status").unwrap_or("open");
    store.upsert(db, tt);
  }
  ui.ok("Import terminé.");
}

export fn stats(db: String) {
  let xs = store.load(db);
  let mut open = 0; let mut done = 0; let mut arch = 0;
  for t in xs {
    if t.status=="open" { open = open + 1; }
    else if t.status=="done" { done = done + 1; }
    else if t.status=="arch" { arch = arch + 1; }
  }
  print("open=" + to_string(open) + " done=" + to_string(done) + " arch=" + to_string(arch));
}

fn join_tags(tags: Vec<String>) -> String {
  let out = "";
  for tg in tags { if len(out)==0 { out=tg } else { out=out+","+tg } }
  out
}

fn today_str() -> String { __intrinsics::today_ymd() }
fn parse_i32(s: String) -> i32 { __intrinsics::atoi_i32(s) }
fn substr(s: String, start: i32) -> String { __intrinsics::substr(s, start, len(s)-start) }
fn add_days(ymd: String, days: i32) -> String { __intrinsics::date_add_days(ymd, days) }

fn lower(s: String) -> String { __intrinsics::to_lower(s) }
fn contains(hay: String, needle: String) -> bool { __intrinsics::str_contains(hay, needle) }

fn extract_json(line: String, key: String) -> Option<String> {
  // ""key"":""value"" pattern naive
  let pat = "\""" + key + "\":\"";
  let i = __intrinsics::str_index_of(line, pat);
  if i < 0 { return None; }
  let j = __intrinsics::str_index_of_from(line, "\"", i+len(pat));
  if j < 0 { return None; }
  Some(__intrinsics::substr(line, i+len(pat), j-(i+len(pat))))
}
